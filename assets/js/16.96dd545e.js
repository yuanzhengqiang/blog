(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{303:function(e,t,r){"use strict";r.r(t);var s=r(38),a=Object(s.a)({},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"浏览器-站点隔离"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器-站点隔离","aria-hidden":"true"}},[e._v("#")]),e._v(" "),r("center",[e._v("浏览器-站点隔离"),r("center")],1)],1),e._v(" "),r("h2",{attrs:{id:"介绍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#介绍","aria-hidden":"true"}},[e._v("#")]),e._v(" 介绍")]),e._v(" "),r("p",[r("strong",[e._v("站点隔离(Site isolation)")]),e._v(" 是 Chrome 为应对潜在的安全问题所实现的功能，以防止恶意网站获取其他网站的信息。")]),e._v(" "),r("p",[e._v("通常，Chrome会把一个标签默认为一个进程，但当网页之间存在共享内容时，彼此可以共享同一个进程。而网站隔离可消除共享进程，确保不同网站在不同的进程上，以此防止发生类似幽灵（Spectre）和熔毁（Meltdown）的攻击。而现在这一功能在Chrome 浏览器中是默认启用的。这就意味着系统将会对诸多令人讨厌的漏洞进行自动防御，但这也意味着Chrome——在其运行时已然占用了计算机的部分资源——现在要多使用10-13%的内存。")]),e._v(" "),r("p",[e._v("有人可能要问，浏览器的同源策略不就是干这个的吗？是的，同源策略确实可以起到保护作用。")]),e._v(" "),r("p",[e._v("Site isolation 提供了第二层的额外保护，将同源策略与进程的地址空间隔离结合起来，把不同的网站隔离在不同的进程中，并且阻止一个进程获得其他网站的敏感信息。这样即使存在 spectre 类型的旁路攻击，可以获取进程内任意内存地址的数据，也不能获得其他网站的信息。")]),e._v(" "),r("p",[e._v("Site Isolation主要由两部分组成。进程模型的修改和跨域读取屏蔽 (CORB)。")]),e._v(" "),r("h3",{attrs:{id:"进程模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#进程模型","aria-hidden":"true"}},[e._v("#")]),e._v(" 进程模型")]),e._v(" "),r("p",[e._v("目前 Chrome 默认的进程模型叫做 process-per-site-instance (还有其他的进程模型如 process-per-site 和 process-per-tab)[3]。这个进程模型基本上就是为每个页面创建一个进程，但是还是存在不同的网站用同一个进程的情况，如 iframes 和父页面，同一个标签页里的页面跳转，以及标签页过多的时候等。Site isolation 引入了一个新的策略叫做 site-per-process。这个策略更为严格，只要是不同的网站，不管你是在新的标签页打开，还是在同一个标签页跳转，还是嵌在 iframes 里，统统都要换一个新的进程。这里主要的工作量是把 iframes 给拿出来放到不同的进程里(所谓的 OOPIF, out of process iframe)。")]),e._v(" "),r("p",[e._v("Firefox 目前也是多进程的模型，但最多只用四个进程来渲染页面内容，目前 Firefox 也有一个文档在考虑进程隔离的问题")]),e._v(" "),r("p",[r("strong",[e._v("不同的网站 (site) 的定义")])]),e._v(" "),r("p",[e._v("使用同一个协议，同一个注册域名 (所谓的 eTLD+1) 的网址都属于同一个网站，这比同源策略里的 same origin 要宽泛一些，不同的子域名，不同的端口都算同一个网站。")]),e._v(" "),r("h3",{attrs:{id:"corb"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#corb","aria-hidden":"true"}},[e._v("#")]),e._v(" CORB")]),e._v(" "),r("p",[e._v("CORB (Cross-Origin Read Blocking) 是一个屏蔽跨域资源加载的功能。")]),e._v(" "),r("p",[e._v("同源策略可以防止恶意网站获取其他网站的信息，但有一些例外如 "),r("code",[e._v("<img>")]),e._v("和"),r("code",[e._v("<script>")]),e._v("。类似:")]),e._v(" "),r("p",[r("code",[e._v('<img src="https://example.com/secret.json">')])]),e._v(" "),r("p",[e._v("的跨站请求可以发起，只是返回的结果被过滤掉了，在解析图片时出错[5]。这时候跨域的资源其实已经传入到了这个进程里面，结合 spectre 类型的旁路攻击或者其他漏洞是可以拿到这些信息的。 CORB 的想法就是直接屏蔽掉跨域资源返回的结果，让地址空间里都没有返回的结果。目前只有HTML，XML 和 JSON 类型的资源会被 CORB 保护。")]),e._v(" "),r("h2",{attrs:{id:"什么是spectre和meltdown攻击？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是spectre和meltdown攻击？","aria-hidden":"true"}},[e._v("#")]),e._v(" 什么是Spectre和Meltdown攻击？")]),e._v(" "),r("p",[e._v("Spectre和Meltdown是同一漏洞的两个不同的变种。")]),e._v(" "),r("p",[e._v("从技术上来说变异有三种。其中两个合并成了Spectre，而另一个是Meltdown。为了访问部分内存，这些攻击会利用所谓的前瞻执行，然后使用时序攻击法来发现存储在那里的数值。")]),e._v(" "),r("p",[r("strong",[e._v("前瞻执行")]),e._v(" 是一种能够帮助芯片运行更快速的机制。用一个例子来说明这一点是最容易的。假设一个程序将要提供一个是或否的选择，而每个答案会导致进入一个不同的进程。与其等待用户进行决策，芯片会开始同时计算这两个功能，因此这便会有一个好的开端，而不管用户会选择什么。")]),e._v(" "),r("p",[e._v("在前瞻执行期间所使用到的数据通常会被保存在CPU缓存中，这就像一个小的内存壁龛，可以帮助加速从RAM中获取数据。")]),e._v(" "),r("p",[e._v("现在，让我们来把所有这些联系在一起。Spectre和Meltdown是利用芯片的前瞻执行功能来达到攻击目的的两种攻击，它们会使用时序攻击法来暴露在这一过程中所加载的数据，然后再把它们转储到CPU缓存中。")])])},[],!1,null,null,null);t.default=a.exports}}]);