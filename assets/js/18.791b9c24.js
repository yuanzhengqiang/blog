(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{312:function(v,_,e){"use strict";e.r(_);var r=e(38),t=Object(r.a)({},function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"渲染过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#渲染过程","aria-hidden":"true"}},[v._v("#")]),v._v(" "),e("center",[v._v("渲染过程")])],1),v._v(" "),e("p",[v._v("渲染进程几乎负责 Tab 内的所有事情，渲染进程的核心目的在于转换 HTML CSS JS 为用户可交互的 web 页面。渲染进程中主要包含以下线程：")]),v._v(" "),e("ul",[e("li",[v._v("主线程 Main thread")]),v._v(" "),e("li",[v._v("工作线程 Worker thread")]),v._v(" "),e("li",[v._v("排版线程 Compositor thread")]),v._v(" "),e("li",[v._v("光栅线程 Raster thread")])]),v._v(" "),e("p",[v._v("接下来我们看下渲染过程:")]),v._v(" "),e("p",[v._v("1."),e("strong",[v._v("构建 DOM")])]),v._v(" "),e("p",[v._v("当渲染进程接收到导航的确认信息，开始接受 HTML 数据时，主线程会解析文本字符串为 DOM。")]),v._v(" "),e("p",[v._v("渲染 html 为 DOM 的方法由 HTML Standard 定义。")]),v._v(" "),e("p",[v._v("2."),e("strong",[v._v("加载次级的资源")])]),v._v(" "),e("p",[v._v("网页中常常包含诸如图片，CSS，JS 等额外的资源，这些资源需要从网络上或者 cache 中获取。主进程可以在构建 DOM 的过程中会逐一请求它们，为了加速 preload scanner 会同时运行，如果在 html 中存在 "),e("code",[v._v("<img>")]),v._v(" "),e("code",[v._v("<link>")]),v._v(" 等标签，preload scanner 会把这些请求传递给 Browser process 中的 network thread 进行相关资源的下载。")]),v._v(" "),e("p",[v._v("3."),e("strong",[v._v("JS 的下载与执行")])]),v._v(" "),e("p",[v._v("当遇到 "),e("code",[v._v("<script>")]),v._v(" 标签时，渲染进程会停止解析 HTML，而去加载，解析和执行 JS 代码，停止解析 html 的原因在于 JS 可能会改变 DOM 的结构（使用诸如 "),e("code",[v._v("document.write()")]),v._v("等API）。")]),v._v(" "),e("p",[v._v("不过开发者其实也有多种方式来告知浏览器应对如何应对某个资源，比如说如果在"),e("code",[v._v("<script>")]),v._v(" 标签上添加了 "),e("code",[v._v("async")]),v._v(" 或 "),e("code",[v._v("defer")]),v._v(" 等属性，浏览器会异步的加载和执行JS代码，而不会阻塞渲染。")]),v._v(" "),e("p",[v._v("4."),e("strong",[v._v("样式计算")])]),v._v(" "),e("p",[v._v("仅仅渲染 DOM 还不足以获知页面的具体样式，主进程还会基于 CSS 选择器解析 CSS 获取每一个节点的最终的计算样式值。即使不提供任何 CSS，浏览器对每个元素也会有一个默认的样式。")]),v._v(" "),e("p",[v._v("5."),e("strong",[v._v("获取布局")])]),v._v(" "),e("p",[v._v("想要渲染一个完整的页面，除了获知每个节点的具体样式，还需要获知每一个节点在页面上的位置，布局其实是找到所有元素的几何关系的过程。其具体过程如下：")]),v._v(" "),e("p",[v._v("通过遍历 DOM 及相关元素的计算样式，主线程会构建出包含每个元素的坐标信息及盒子大小的布局树。布局树和 DOM 树类似，但是其中只包含页面可见的元素，如果一个元素设置了 "),e("code",[v._v("display:none")]),v._v(" ，这个元素不会出现在布局树上，伪元素虽然在 DOM 树上不可见，但是在布局树上是可见的。")]),v._v(" "),e("p",[v._v("6."),e("strong",[v._v("绘制各元素")])]),v._v(" "),e("p",[v._v("即使知道了不同元素的位置及样式信息，我们还需要知道不同元素的绘制先后顺序才能正确绘制出整个页面。在绘制阶段，主线程会遍历布局树以创建绘制记录。绘制记录可以看做是记录各元素绘制先后顺序的笔记。")]),v._v(" "),e("p",[v._v("7."),e("strong",[v._v("合成帧")])]),v._v(" "),e("p",[v._v("熟悉 PS 等绘图软件的童鞋肯定对图层这一概念不陌生，现代 Chrome 其实利用了这一概念来组合不同的层。")]),v._v(" "),e("p",[v._v("复合是一种分割页面为不同的层，并单独栅格化，随后组合为帧的技术。不同层的组合由 compositor 线程（合成器线程）完成。")]),v._v(" "),e("p",[v._v("主线程会遍历布局树来创建层树（layer tree），添加了 "),e("code",[v._v("will-change")]),v._v(" CSS 属性的元素，会被看做单独的一层;")]),v._v(" "),e("p",[v._v("你可能会想给每一个元素都添加上 "),e("code",[v._v("will-change")]),v._v("，不过组合过多的层也许会比在每一帧都栅格化页面中的某些小部分更慢。为了更合理的使用层，可参考 "),e("a",{attrs:{href:"https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count",target:"_blank",rel:"noopener noreferrer"}},[v._v("坚持仅合成器的属性和管理层计数"),e("OutboundLink")],1),v._v(" 。")]),v._v(" "),e("p",[v._v("一旦层树被创建，渲染顺序被确定，主线程会把这些信息通知给合成器线程，合成器线程会栅格化每一层。有的层的可以达到整个页面的大小，因此，合成器线程将它们分成多个磁贴，并将每个磁贴发送到栅格线程，栅格线程会栅格化每一个磁贴并存储在 GPU 显存中。")]),v._v(" "),e("p",[v._v("一旦磁贴被光栅化，合成器线程会收集称为绘制四边形的磁贴信息以创建合成帧。")]),v._v(" "),e("p",[v._v("合成帧随后会通过 IPC 消息传递给浏览器进程，由于浏览器的 UI 改变或者其它拓展的渲染进程也可以添加合成帧，这些合成帧会被传递给 GPU 用以展示在屏幕上，如果滚动发生，合成器线程会创建另一个合成帧发送给 GPU。")]),v._v(" "),e("p",[v._v("合成器的优点在于，其工作无关主线程，合成器线程不需要等待样式计算或者 JS 执行，这就是为什么合成器相关的动画 最流畅，如果某个动画涉及到布局或者绘制的调整，就会涉及到主线程的重新计算，自然会慢很多。")])])},[],!1,null,null,null);_.default=t.exports}}]);