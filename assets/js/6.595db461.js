(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{421:function(_,v,t){_.exports=t.p+"assets/img/tcp-connection-made-three-way-handshake.dc84424c.png"},422:function(_,v,t){_.exports=t.p+"assets/img/tcp-buffer.bce3ff4e.jpg"},423:function(_,v,t){_.exports=t.p+"assets/img/tcp-sliding-window.03bb82da.jpg"},424:function(_,v,t){_.exports=t.p+"assets/img/tcp-sliding-processes.d3037487.jpg"},425:function(_,v,t){_.exports=t.p+"assets/img/tcp-retransmission.5fb7259a.jpg"},426:function(_,v,t){_.exports=t.p+"assets/img/tcp-connection-closed-four-way-handshake.69f6d366.png"},427:function(_,v,t){_.exports=t.p+"assets/img/TCP-handshake.2f5f3733.jpg"},470:function(_,v,t){"use strict";t.r(v);var a=t(43),s=Object(a.a)({},(function(){var _=this,v=_.$createElement,a=_._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h1",{attrs:{id:"tcp协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp协议"}},[_._v("#")]),_._v(" "),a("center",[_._v("TCP协议")])],1),_._v(" "),a("h3",{attrs:{id:"tcp-的特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp-的特性"}},[_._v("#")]),_._v(" TCP 的特性")]),_._v(" "),a("ul",[a("li",[_._v("TCP 提供一种"),a("strong",[_._v("面向连接")]),_._v("的、"),a("strong",[_._v("可靠")]),_._v("的字节流服务")]),_._v(" "),a("li",[_._v("在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP")]),_._v(" "),a("li",[_._v("TCP 使用校验和，确认和重传机制来保证可靠传输")]),_._v(" "),a("li",[_._v("TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复")]),_._v(" "),a("li",[_._v("TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制")])]),_._v(" "),a("p",[a("strong",[_._v("注意")]),_._v("：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。")]),_._v(" "),a("h2",{attrs:{id:"三次握手-建立链接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三次握手-建立链接"}},[_._v("#")]),_._v(" 三次握手-建立链接")]),_._v(" "),a("p",[_._v("所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。")]),_._v(" "),a("p",[_._v("三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。")]),_._v(" "),a("ul",[a("li",[a("p",[_._v("第一次握手(SYN=1, seq=x):")]),_._v(" "),a("p",[_._v("客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。")]),_._v(" "),a("p",[_._v("发送完毕后，客户端进入 SYN_SEND 状态。")])]),_._v(" "),a("li",[a("p",[_._v("第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):")]),_._v(" "),a("p",[_._v("服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端初始化自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。")])]),_._v(" "),a("li",[a("p",[_._v("第三次握手(ACK=1，ACKnum=y+1)")]),_._v(" "),a("p",[_._v("客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1")]),_._v(" "),a("p",[_._v("发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。")])])]),_._v(" "),a("p",[_._v("三次握手的过程的示意图如下：")]),_._v(" "),a("p",[a("img",{attrs:{src:t(421),alt:"sss"}})]),_._v(" "),a("h3",{attrs:{id:"为什么是三次握手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么是三次握手"}},[_._v("#")]),_._v(" 为什么是三次握手")]),_._v(" "),a("ul",[a("li",[_._v("tcp连接是全双工的，数据在两个方向上能同时传递。")]),_._v(" "),a("li",[_._v("所以要确保双方，同时能发数据和收数据")]),_._v(" "),a("li",[_._v("第一次握手：证明了发送方能发数据")]),_._v(" "),a("li",[_._v("第二次握手：ack确保了接收方能收数据，syn确保了接收方能发数据")]),_._v(" "),a("li",[_._v("第三次握手：确保了发送方能收数据")]),_._v(" "),a("li",[_._v("实际上是四个维度的信息交换，不过中间两步合并为一次握手了。")]),_._v(" "),a("li",[_._v("四次握手浪费，两次握手不能保证“双方同时具备收发功能”")])]),_._v(" "),a("p",[_._v("为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。")]),_._v(" "),a("h3",{attrs:{id:"序列号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#序列号"}},[_._v("#")]),_._v(" 序列号")]),_._v(" "),a("p",[_._v("在上文中提到的初始化 "),a("strong",[_._v("序列号")]),_._v(" (英文为：Initial Sequence Number，简称"),a("strong",[_._v("ISN")]),_._v(");")]),_._v(" "),a("p",[_._v("TCP初始化序列号不能设置为一个固定值，因为这样容易被攻击者猜出后续序列号，从而遭到攻击。")]),_._v(" "),a("p",[_._v("RFC1948中提出了一个较好的初始化序列号ISN随机生成算法。")]),_._v(" "),a("p",[a("strong",[a("center",[_._v("ISN = M + F(localhost, localport, remotehost, remoteport)")])],1)]),_._v(" "),a("ul",[a("li",[a("p",[a("strong",[_._v("M")]),_._v("是一个计时器，这个计时器每隔4毫秒加1。")])]),_._v(" "),a("li",[a("p",[a("strong",[_._v("F")]),_._v("是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出，用"),a("strong",[_._v("MD5")]),_._v("算法是一个比较好的选择。")])])]),_._v(" "),a("h4",{attrs:{id:"初始化序列号的目的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#初始化序列号的目的"}},[_._v("#")]),_._v(" 初始化序列号的目的")]),_._v(" "),a("p",[_._v("由于A和B之间的一个tcp连接通常是由A和B的2个ip地址，2个端口号构成的四元组，因此当A出现了故障把这个tcp连接断开了，之后再以相同的四元组建立新的tcp连接（也就是说A和B两次建立tcp连接都是使用了相同的ip地址和端口），就会出现数据乱序的问题。")]),_._v(" "),a("p",[_._v("换句话说，只要A发送了一个tcp报文段，且这个tcp报文段的四元组和序号，和之前的tcp连接（四元组和序号）相同的话，就会被B确认。这其实反映了tcp的一些缺点，如果被一些恶意攻击者加以利用tcp的这种缺点：选择合适的序号，ip地址和端口的话，就能伪造出一个tcp报文段，从而打断正常的tcp连接。但是初始化序号的方式（通过算法来随机生成序号）就会使序号难以猜出，也就不容易利用这种缺点来进行一些恶意攻击行为。")]),_._v(" "),a("p",[_._v("通过上面所述我们知道，如果A和B之间发送数据每次都使用相同序号的话可能会引发一系列的问题，但是使用不同序号的话，那么B在接收到这个序号为1的tcp报文时，发现这个tcp报文的序号不在新tcp连接的接收范围内时会把这个tcp报文丢弃掉，也就避免了数据乱序的问题。")]),_._v(" "),a("p",[_._v("因此我们可以明白，客户端和服务端双方在建立tcp连接并初始化序列号，那么上面所说的这些情况从一开始就可以避免。另外，tcp在初始化序列号的过程也是比较复杂的，一般来说，这个序号的范围是0 ~ 2^31之间，而且序号的生成也是随机的，通常是一个很大的数值，也就是说每个tcp连接使用的序号也是不一样的。")]),_._v(" "),a("h3",{attrs:{id:"tcp-缓冲区的数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp-缓冲区的数据结构"}},[_._v("#")]),_._v(" TCP 缓冲区的数据结构")]),_._v(" "),a("p",[a("img",{attrs:{src:t(422),alt:"数据结构图"}})]),_._v(" "),a("ul",[a("li",[a("p",[_._v("接收端：")]),_._v(" "),a("ul",[a("li",[_._v("LastByteRead: 缓冲区读取到的位置")]),_._v(" "),a("li",[_._v("NextByteExpected：收到的连续包的最后一个位置")]),_._v(" "),a("li",[_._v("LastByteRcvd：收到的包的最后一个位置")]),_._v(" "),a("li",[_._v("中间空白区：数据没有到达")])])]),_._v(" "),a("li",[a("p",[_._v("发送端：")]),_._v(" "),a("ul",[a("li",[_._v("LastByteAcked: 被接收端ack的位置，表示成功发送确认")]),_._v(" "),a("li",[_._v("LastByteSent：发出去了，还没有收到成功确认的Ack")]),_._v(" "),a("li",[_._v("LastByteWritten：上层应用正在写的地方")])])])]),_._v(" "),a("h3",{attrs:{id:"滑动窗口示意图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口示意图"}},[_._v("#")]),_._v(" 滑动窗口示意图")]),_._v(" "),a("h4",{attrs:{id:"滑动初始示意图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#滑动初始示意图"}},[_._v("#")]),_._v(" 滑动初始示意图")]),_._v(" "),a("p",[a("img",{attrs:{src:t(423),alt:"初始示意图"}})]),_._v(" "),a("ul",[a("li",[_._v("黑框表示滑动窗口")]),_._v(" "),a("li",[_._v("'#1'表示收到ack确认的数据")]),_._v(" "),a("li",[_._v("'#2'表示还没收到ack的数据")]),_._v(" "),a("li",[_._v("'#3'表示在窗口中还没有发出的（接收方还有空间）")]),_._v(" "),a("li",[_._v("'#4'窗口以外的数据（接收方没空间）")])]),_._v(" "),a("h4",{attrs:{id:"滑动过程示意图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#滑动过程示意图"}},[_._v("#")]),_._v(" 滑动过程示意图")]),_._v(" "),a("p",[a("img",{attrs:{src:t(424),alt:"滑动过程"}})]),_._v(" "),a("ul",[a("li",[_._v("收到36的ack，并发出46-51的字节")])]),_._v(" "),a("h4",{attrs:{id:"拥塞窗口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拥塞窗口"}},[_._v("#")]),_._v(" 拥塞窗口")]),_._v(" "),a("ul",[a("li",[_._v("解决什么问题：发送方发送速度过快，导致中转路由器拥堵的问题")]),_._v(" "),a("li",[_._v("机制：发送方增加一个拥塞窗口（cwnd），每次受到ack，窗口值加1。发送时，取拥塞窗口和接收方发来的窗口大小取最小值发送")]),_._v(" "),a("li",[_._v("起到发送方流量控制的作用")])]),_._v(" "),a("h4",{attrs:{id:"滑动窗口会引发的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口会引发的问题"}},[_._v("#")]),_._v(" 滑动窗口会引发的问题")]),_._v(" "),a("h5",{attrs:{id:"零窗口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#零窗口"}},[_._v("#")]),_._v(" 零窗口")]),_._v(" "),a("ul",[a("li",[_._v("如何发生： 接收端处理速度慢，发送端发送速度快。窗口大小慢慢被调为0")]),_._v(" "),a("li",[_._v("如何解决：ZWP技术。发送zwp包给接收方，让接收方ack他的窗口大小。")])]),_._v(" "),a("h4",{attrs:{id:"糊涂窗口综合征"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#糊涂窗口综合征"}},[_._v("#")]),_._v(" 糊涂窗口综合征")]),_._v(" "),a("ul",[a("li",[_._v("如何发生：接收方太忙，取不完数据，导致发送方越来越小。最后只让发送方传几字节的数据。")]),_._v(" "),a("li",[_._v("缺点：数据比tcp和ip头小太多，网络利用率太低。")]),_._v(" "),a("li",[_._v("如何解决：避免对小的窗口大小做响应。\n"),a("ul",[a("li",[_._v("发送端：前面说到的Nagle算法。")]),_._v(" "),a("li",[_._v("接收端：窗口大小小于某个值，直接ack（0），阻止发送数据。窗口变大后再发。")])])])]),_._v(" "),a("h4",{attrs:{id:"拥塞处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拥塞处理"}},[_._v("#")]),_._v(" 拥塞处理")]),_._v(" "),a("ul",[a("li",[_._v("拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。")]),_._v(" "),a("li",[_._v("拥塞处理包括了四个算法，分别为："),a("strong",[_._v("慢开始")]),_._v("，"),a("strong",[_._v("拥塞避免")]),_._v("，"),a("strong",[_._v("快速重传")]),_._v("，"),a("strong",[_._v("快速恢复")])])]),_._v(" "),a("h5",{attrs:{id:"慢开始算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#慢开始算法"}},[_._v("#")]),_._v(" 慢开始算法")]),_._v(" "),a("blockquote",[a("p",[_._v("慢开始算法，顾名思义，就是在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。想必大家都下载过资源，每当我们开始下载的时候都会发现下载速度是慢慢提升的，而不是一蹴而就直接拉满带宽")])]),_._v(" "),a("ul",[a("li",[a("p",[_._v("慢开始算法步骤具体如下:")])]),_._v(" "),a("li",[a("p",[_._v("连接初始设置拥塞窗口（Congestion Window） 为 "),a("code",[_._v("1 MSS")]),_._v("（一个分段的最大数据量）")])]),_._v(" "),a("li",[a("p",[_._v("每过一个 "),a("code",[_._v("RTT")]),_._v(" 就将窗口大小乘二")])]),_._v(" "),a("li",[a("p",[_._v("指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法。")])])]),_._v(" "),a("h5",{attrs:{id:"拥塞避免算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拥塞避免算法"}},[_._v("#")]),_._v(" 拥塞避免算法")]),_._v(" "),a("ul",[a("li",[_._v("拥塞避免算法相比简单点，每过一个 "),a("code",[_._v("RTT")]),_._v(" 窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。")]),_._v(" "),a("li",[_._v("在传输过程中可能定时器超时的情况，这时候 "),a("code",[_._v("TCP")]),_._v(" 会认为网络拥塞了，会马上进行以下步骤：")])]),_._v(" "),a("ol",[a("li",[_._v("将阈值设为当前拥塞窗口的一半")]),_._v(" "),a("li",[_._v("将拥塞窗口设为 "),a("code",[_._v("1 MSS")])]),_._v(" "),a("li",[_._v("启动拥塞避免算法")])]),_._v(" "),a("h5",{attrs:{id:"快速重传"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#快速重传"}},[_._v("#")]),_._v(" 快速重传")]),_._v(" "),a("blockquote",[a("p",[_._v("快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号。如果发送端收到三个重复的 ACK，无需等待定时器超时而是直接启动快速重传算法。具体算法分为两种：")])]),_._v(" "),a("ul",[a("li",[a("p",[_._v("TCP Taho 实现如下")])]),_._v(" "),a("li",[a("p",[_._v("将阈值设为当前拥塞窗口的一半")])]),_._v(" "),a("li",[a("p",[_._v("将拥塞窗口设为 "),a("code",[_._v("1 MSS")])])]),_._v(" "),a("li",[a("p",[_._v("重新开始慢开始算法")])]),_._v(" "),a("li",[a("p",[a("code",[_._v("TCP Reno")]),_._v(" 实现如下")])])]),_._v(" "),a("h5",{attrs:{id:"拥塞窗口减半"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拥塞窗口减半"}},[_._v("#")]),_._v(" 拥塞窗口减半")]),_._v(" "),a("ul",[a("li",[_._v("将阈值设为当前拥塞窗口")]),_._v(" "),a("li",[_._v("进入快恢复阶段（重发对端需要的包，一旦收到一个新的 ACK 答复就退出该阶段），这种方式在丢失多个包的情况下就不那么好了")]),_._v(" "),a("li",[_._v("使用拥塞避免算法")])]),_._v(" "),a("h5",{attrs:{id:"tcp-new-ren-改进后的快恢复"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp-new-ren-改进后的快恢复"}},[_._v("#")]),_._v(" TCP New Ren 改进后的快恢复")]),_._v(" "),a("ul",[a("li",[_._v("TCP New Reno 算法改进了之前 TCP Reno 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。")]),_._v(" "),a("li",[_._v("``在 TCP New Reno 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。")])]),_._v(" "),a("h3",{attrs:{id:"超时重传机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#超时重传机制"}},[_._v("#")]),_._v(" 超时重传机制")]),_._v(" "),a("h4",{attrs:{id:"背景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[_._v("#")]),_._v(" 背景")]),_._v(" "),a("ul",[a("li",[_._v("接收端给发送端的Ack确认只会确认最后一个连续的包")]),_._v(" "),a("li",[_._v("比如发送1,2,3,4,5共五份数据，接收端收到1,2，于是回ack3，然后收到4（还没收到3），此时tcp不会跳过3直接确认4，否则发送端以为3也收到了。这时你能想到的方法是什么呢？tcp又是怎么处理的呢？")])]),_._v(" "),a("h4",{attrs:{id:"被动等待的超时重传策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#被动等待的超时重传策略"}},[_._v("#")]),_._v(" 被动等待的超时重传策略")]),_._v(" "),a("ul",[a("li",[_._v("直观的方法是：接收方不做任何处理，等待发送方超时，然后重传。\n"),a("ul",[a("li",[_._v("缺点：发送端不知道该重发3，还是重发3,4,5")])])]),_._v(" "),a("li",[_._v("如果发送方如果只发送3：节省宽度，但是慢")]),_._v(" "),a("li",[_._v("如果发送方如果发送3,4,5：快，但是浪费宽带")]),_._v(" "),a("li",[_._v("总之，都在被动等待超时，超时可能很长。所以tcp不采用此方法")])]),_._v(" "),a("h4",{attrs:{id:"主动的快速重传机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主动的快速重传机制"}},[_._v("#")]),_._v(" 主动的快速重传机制")]),_._v(" "),a("p",[_._v("英文名为：Fast Retransmit, 不以实际驱动，而以数据驱动重传")]),_._v(" "),a("h5",{attrs:{id:"实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现原理"}},[_._v("#")]),_._v(" 实现原理")]),_._v(" "),a("ul",[a("li",[_._v("如果包没有送达，就一直ack最后那个可能被丢的包")]),_._v(" "),a("li",[_._v("发送方连续收到3相同的ack，就重传。不用等待超时")])]),_._v(" "),a("p",[a("img",{attrs:{src:t(425),alt:"tcp-重传"}})]),_._v(" "),a("ul",[a("li",[_._v("图中发生1,2,3,4,5数据")]),_._v(" "),a("li",[_._v("数据1到达，发生ack2")]),_._v(" "),a("li",[_._v("数据2因为某些原因没有送到")]),_._v(" "),a("li",[_._v("后续收到3的时候，接收端并不是ack4，也不是等待。而是主动ack2")]),_._v(" "),a("li",[_._v("收到4,5同理，一直主动ack2")]),_._v(" "),a("li",[_._v("客户端收到三次ack2，就重传2")]),_._v(" "),a("li",[_._v("2收到后，结合之前收到的3,4,5，直接ack6")])]),_._v(" "),a("h5",{attrs:{id:"快速重传的利弊"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#快速重传的利弊"}},[_._v("#")]),_._v(" 快速重传的利弊")]),_._v(" "),a("ul",[a("li",[_._v("解决了被动等待timeout的问题")]),_._v(" "),a("li",[_._v("无法解决重传之前的一个，还是所有的问题。")]),_._v(" "),a("li",[_._v("上面的例子中是重传2，还是重传2,3,4,5。因为并不清楚ack2是谁传回来的")])]),_._v(" "),a("h4",{attrs:{id:"sack方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sack方法"}},[_._v("#")]),_._v(" SACK方法")]),_._v(" "),a("ul",[a("li",[_._v("为了解决快速重传的缺点，一种更好的SACK重传策略被提出")]),_._v(" "),a("li",[_._v("基于快速重传，同时在tcp头里加了一个SACK的东西")]),_._v(" "),a("li",[_._v("解决了什么问题：客户端应该发送哪些超时包的问题")])]),_._v(" "),a("h5",{attrs:{id:"实现原理-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现原理-2"}},[_._v("#")]),_._v(" 实现原理")]),_._v(" "),a("ul",[a("li",[_._v("SACK记录一个数值范围，表示哪些数据收到了")]),_._v(" "),a("li",[_._v("linux2.4后默认打开该功能，之前版本需要配置tcp-sack参数")]),_._v(" "),a("li",[_._v("SACK只是一种辅助的方式，发送方不能完全依赖SACK。主要还是依赖ACK和timout")])]),_._v(" "),a("h5",{attrs:{id:"duplicate-sack-d-sack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#duplicate-sack-d-sack"}},[_._v("#")]),_._v(" Duplicate SACK(D-SACK)")]),_._v(" "),a("ul",[a("li",[_._v("使用SACK标识的范围，还可以知道告知发送方，有哪些数据被重复接收了")]),_._v(" "),a("li",[_._v("可以让发送方知道：是发出去的包丢了，还是回来的ack包丢了")])]),_._v(" "),a("h3",{attrs:{id:"超时时间的确定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#超时时间的确定"}},[_._v("#")]),_._v(" 超时时间的确定")]),_._v(" "),a("h4",{attrs:{id:"背景-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#背景-2"}},[_._v("#")]),_._v(" 背景")]),_._v(" "),a("ul",[a("li",[_._v("路由器和网络流量均会变化")]),_._v(" "),a("li",[_._v("所以超时时间肯定不能设置为一个固定值")]),_._v(" "),a("li",[_._v("超时长：重发慢，效率低，性能差")]),_._v(" "),a("li",[_._v("超时短：并没有丢就重发，导致网络拥塞，导致更多超时和更多重发")]),_._v(" "),a("li",[_._v("tcp会追踪这些变化，并相应的动态改变超时时间（RTO）")])]),_._v(" "),a("h4",{attrs:{id:"如何动态改变"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何动态改变"}},[_._v("#")]),_._v(" 如何动态改变")]),_._v(" "),a("ul",[a("li",[_._v("每次重传的时间间隔为上次的一倍，直到最大间隔为64s，称为“指数退避”")]),_._v(" "),a("li",[_._v("首次重传到最后放弃重传的时间间隔一般为9min")]),_._v(" "),a("li",[_._v("依赖以往的往返时间计算（RTT）动态的计算")])]),_._v(" "),a("h4",{attrs:{id:"往返时间（rtt）的计算方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#往返时间（rtt）的计算方法"}},[_._v("#")]),_._v(" 往返时间（RTT）的计算方法")]),_._v(" "),a("ul",[a("li",[_._v("并不是简单的ack时间和发送时间的差值。因为有重传，网络阻塞等各种变化的因素。")]),_._v(" "),a("li",[_._v("而是通过采样多次数值，然后做估算")]),_._v(" "),a("li",[_._v("tcp使用的方法有：\n"),a("ul",[a("li",[_._v("被平滑的RTT估计器")]),_._v(" "),a("li",[_._v("被平滑的均值偏差估计器")])])])]),_._v(" "),a("h4",{attrs:{id:"重传时间的具体计算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重传时间的具体计算"}},[_._v("#")]),_._v(" 重传时间的具体计算")]),_._v(" "),a("ul",[a("li",[_._v("计算往返时间（RTT），保存测量结果")]),_._v(" "),a("li",[_._v("通过测量结果维护一个被平滑的RTT估计器和被平滑的均值偏差估计器")]),_._v(" "),a("li",[_._v("根据这两个估计器计算下一次重传时间")])]),_._v(" "),a("h3",{attrs:{id:"超时重传引发的问题-拥塞"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#超时重传引发的问题-拥塞"}},[_._v("#")]),_._v(" 超时重传引发的问题-拥塞")]),_._v(" "),a("h4",{attrs:{id:"为什么重传会引发拥塞"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么重传会引发拥塞"}},[_._v("#")]),_._v(" 为什么重传会引发拥塞")]),_._v(" "),a("ul",[a("li",[_._v("当网络延迟突然增加时，tcp会重传数据")]),_._v(" "),a("li",[_._v("但是过多的重传会导致网络负担加重，从而导致更大的延时和丢包，进入恶性循环")]),_._v(" "),a("li",[_._v("也就是tcp的拥塞问题")])]),_._v(" "),a("h4",{attrs:{id:"解决拥塞-拥塞控制的算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决拥塞-拥塞控制的算法"}},[_._v("#")]),_._v(" 解决拥塞-拥塞控制的算法")]),_._v(" "),a("ul",[a("li",[_._v("慢启动：降低分组进入网络的传输速率")]),_._v(" "),a("li",[_._v("拥塞避免：处理丢失分组的算法")]),_._v(" "),a("li",[_._v("快速重传")]),_._v(" "),a("li",[_._v("快速恢复")])]),_._v(" "),a("h2",{attrs:{id:"四次挥手-关闭链接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手-关闭链接"}},[_._v("#")]),_._v(" 四次挥手-关闭链接")]),_._v(" "),a("p",[_._v("TCP 的连接的关闭需要发送四个包，因此称为"),a("strong",[_._v("四次挥手")]),_._v("(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。")]),_._v(" "),a("ul",[a("li",[a("p",[_._v("第一次挥手(FIN=1，seq=x)")]),_._v(" "),a("p",[_._v("假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。")]),_._v(" "),a("p",[_._v("发送完毕后，客户端进入 FIN_WAIT_1 状态。")])]),_._v(" "),a("li",[a("p",[_._v("第二次挥手(ACK=1，ACKnum=x+1)")]),_._v(" "),a("p",[_._v("服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。")]),_._v(" "),a("p",[_._v("发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。")])]),_._v(" "),a("li",[a("p",[_._v("第三次挥手(FIN=1，seq=y)")]),_._v(" "),a("p",[_._v("服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。")]),_._v(" "),a("p",[_._v("发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。")])]),_._v(" "),a("li",[a("p",[_._v("第四次挥手(ACK=1，ACKnum=y+1)")]),_._v(" "),a("p",[_._v("客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。")]),_._v(" "),a("p",[_._v("服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。")]),_._v(" "),a("p",[_._v("客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。")])])]),_._v(" "),a("p",[_._v("四次挥手的示意图如下：\n"),a("img",{attrs:{src:t(426),alt:"四次挥手"}})]),_._v(" "),a("h3",{attrs:{id:"为什么是四次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么是四次挥手"}},[_._v("#")]),_._v(" 为什么是四次挥手")]),_._v(" "),a("ul",[a("li",[_._v("因为tcp连接是全双工的，数据在两个方向上能同时传递。")]),_._v(" "),a("li",[_._v("同时tcp支持半关闭（发送一方结束发送还能接收数据的功能）。")]),_._v(" "),a("li",[_._v("因此每个方向都要单独关闭，且收到关系通知需要发送确认回复。")])]),_._v(" "),a("h4",{attrs:{id:"为什么要支持半关闭"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要支持半关闭"}},[_._v("#")]),_._v(" 为什么要支持半关闭")]),_._v(" "),a("ul",[a("li",[_._v("客户端需要通知服务端，它的数据已经传输完毕")]),_._v(" "),a("li",[_._v("同时仍要接收来自服务端的数据")]),_._v(" "),a("li",[_._v("使用半关闭的单连接效率要比使用两个tcp连接更好")])]),_._v(" "),a("h2",{attrs:{id:"tcp-慢开始-14kb-规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp-慢开始-14kb-规则"}},[_._v("#")]),_._v(" TCP 慢开始 / 14kb 规则")]),_._v(" "),a("p",[_._v("第一个响应包是14kb大小。这是慢开始的一部分，慢开始是一种均衡网络连接速度的算法。慢开始逐渐增加发送数据的数量直到达到网络的最大带宽。")]),_._v(" "),a("p",[_._v('在"TCP slow start"中，在收到初始包之后, 服务器会将下一个包的大小加倍到大约28kb。 后续的包依次是前一个包大小的二倍直到达到预定的阈值，或者遇到拥塞。')]),_._v(" "),a("p",[a("img",{attrs:{src:t(427),alt:"TCP-handshake"}})]),_._v(" "),a("p",[_._v("如果您听说过初始页面加载的14Kb规则，TCP慢开始就是初始响应为14Kb的原因，也是为什么web性能优化需要将此初始14Kb响应作为优化重点的原因。TCP慢开始逐渐建立适合网络能力的传输速度，以避免拥塞。")]),_._v(" "),a("h2",{attrs:{id:"tcp-keepalive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp-keepalive"}},[_._v("#")]),_._v(" TCP KeepAlive")]),_._v(" "),a("p",[_._v("TCP 的连接，实际上是一种纯软件层面的概念，在物理层面并没有“连接”这种概念。TCP 通信双方建立交互的连接，但是并不是一直存在数据交互，有些连接会在数据交互完毕后，主动释放连接，而有些不会。在长时间无数据交互的时间段内，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些 TCP 连接并未来得及正常释放，在软件层面上，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用 TCP 的 KeepAlive 机制实现来实现。主流的操作系统基本都在内核里支持了这个特性。")]),_._v(" "),a("p",[_._v("TCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。")]),_._v(" "),a("Valine")],1)}),[],!1,null,null,null);v.default=s.exports}}]);