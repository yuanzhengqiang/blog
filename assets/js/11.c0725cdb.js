(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{416:function(t,a,v){t.exports=v.p+"assets/img/HTTP-cache.2657e1f6.png"},417:function(t,a,v){t.exports=v.p+"assets/img/HTTP-cache1.10b59301.png"},418:function(t,a,v){t.exports=v.p+"assets/img/HTTP-cache2.48f982ec.png"},468:function(t,a,v){"use strict";v.r(a);var _=v(43),e=Object(_.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"http缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http缓存"}},[t._v("#")]),t._v(" "),_("center",[t._v("HTTP缓存")])],1),t._v(" "),_("p",[t._v("Http 缓存机制作为 web 性能优化的重要手段，对于从事 Web 开发的同学们来说，应该是知识体系库中的一个基础环节，同时对于有志成为前端架构师的同学来说是必备的知识技能。")]),t._v(" "),_("h2",{attrs:{id:"缓存的优点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存的优点"}},[t._v("#")]),t._v(" "),_("strong",[t._v("缓存的优点")])]),t._v(" "),_("p",[t._v("减少了冗余的数据传递，节省宽带流量")]),t._v(" "),_("p",[t._v("减少了服务器的负担，大大提高了网站性能")]),t._v(" "),_("p",[t._v("加快了客户端加载网页的速度 这也正是HTTP缓存属于客户端缓存的原因")]),t._v(" "),_("h2",{attrs:{id:"缓存规则解析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存规则解析"}},[t._v("#")]),t._v(" 缓存规则解析")]),t._v(" "),_("p",[t._v("为方便大家理解，我们认为浏览器存在一个缓存数据库,用于存储缓存信息。\n在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中。")]),t._v(" "),_("p",[_("img",{attrs:{src:v(416),alt:"img"}})]),t._v(" "),_("p",[t._v("HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类(强制缓存，对比缓存)\n在详细介绍这两种规则之前，先通过时序图的方式，让大家对这两种规则有个简单了解。")]),t._v(" "),_("p",[t._v("已存在缓存数据时，仅基于强制缓存，请求数据的流程如下：")]),t._v(" "),_("p",[_("img",{attrs:{src:v(417),alt:"HTTP-cache1"}})]),t._v(" "),_("p",[t._v("已存在缓存数据时，仅基于对比缓存，请求数据的流程如下:")]),t._v(" "),_("p",[_("img",{attrs:{src:v(418),alt:"HTTP-cache3"}})]),t._v(" "),_("p",[t._v("对缓存机制不太了解的同学可能会问，基于对比缓存的流程下，不管是否使用缓存，都需要向服务器发送请求，那么还用缓存干什么？\n这个问题，我们暂且放下，后文在详细介绍每种缓存规则的时候，会带给大家答案。")]),t._v(" "),_("p",[t._v("我们可以看到两类缓存规则的不同，强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互。\n两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。")]),t._v(" "),_("h2",{attrs:{id:"强制缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#强制缓存"}},[t._v("#")]),t._v(" 强制缓存")]),t._v(" "),_("p",[t._v("从上文我们得知，强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，那么浏览器是如何判断缓存数据是否失效呢？\n我们知道，在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应header中。")]),t._v(" "),_("p",[t._v("对于强制缓存来说，响应header中会有两个字段来标明失效规则（Expires/Cache-Control）\n使用chrome的开发者工具，可以很明显的看到对于强制缓存生效时，网络请求的情况")]),t._v(" "),_("h3",{attrs:{id:"expires"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[t._v("#")]),t._v(" Expires")]),t._v(" "),_("ul",[_("li",[t._v("Expires是http1.0时代处理缓存的方式，用来启用缓存和定义缓存时间。Expires的值对应一个GMT（格林尼治时间），比如“Wed, 24 Jun 2020 03:33:06 GMT”来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。")]),t._v(" "),_("li",[t._v("与之对应的有Pragma字段，当该字段值为“no-cache”的时候禁止缓存，即每次都发送新的请求。")]),t._v(" "),_("li",[t._v("需要注意的是Pragma字段的优先级会更高，也就是说当Pragma设置为禁用，又给Expires定义一个还未到期的时间，这是还是会发起新的请求")]),t._v(" "),_("li",[t._v("缺点：响应报文中Expires所定义的缓存时间是相对服务器上的时间而言的，如果客户端上的时间跟服务器上的时间不一致，那缓存时间可能就没意义了")])]),t._v(" "),_("h3",{attrs:{id:"cache-control"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[t._v("#")]),t._v(" Cache-Control")]),t._v(" "),_("ul",[_("li",[_("blockquote",[_("p",[t._v("上述的Expires时间是相对服务器而言，无法保证和客户端时间统一,http1.1新增了 Cache-Control 来定义缓存过期时间,若报文中同时出现了 Pragma、Expires 和 Cache-Control，会以 Cache-Control 为准")])]),t._v(" "),_("h3",{attrs:{id:"作为request-headres时候可取值"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#作为request-headres时候可取值"}},[t._v("#")]),t._v(" 作为Request Headres时候可取值")]),t._v(" "),_("ul",[_("li",[t._v("no-cache > 告知服务器不直接使用缓存，要求原服务器发送请求")]),t._v(" "),_("li",[t._v("no-store > 所有内容都不会被保存到缓存或Internet临时文件中")]),t._v(" "),_("li",[t._v("max-age=delta-seconds > 告知服务器客户端希望接收一个存在时间（Age）不大于delta-seconds秒的资源")]),t._v(" "),_("li",[t._v("max-stale [= delta-seconds] > 告知服务器客户端愿意接收一个超过缓存时间的资源，若有定义delta-seconds则为delta-seconds秒，若没有定义则为任意超出时间")]),t._v(" "),_("li",[t._v("min-fresh=delta-seconds > 告知服务器客户端希望接收一个在小于delta-seconds秒内被更新过的资源")])]),t._v(" "),_("h3",{attrs:{id:"作为response-headres时候可取值"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#作为response-headres时候可取值"}},[t._v("#")]),t._v(" 作为Response Headres时候可取值")]),t._v(" "),_("ul",[_("li",[t._v("public > 表明任何情况下都得缓存该资源（即使是需要http认证的资源）")]),t._v(" "),_("li",[t._v('private[="field-name"] > 表明返回报文中全部或部分（若指定了field-name则为field-name的字段数据）仅开放给部分用户（服务器指定的share-user）做缓存使用，其他用户则不能缓存这些数据')]),t._v(" "),_("li",[t._v("no-cache > 不直接使用缓存，要求向服务器发起（新鲜度校验）请求")]),t._v(" "),_("li",[t._v("no-store > 所有内容都不会被保存到缓存或Internet临时文件中")]),t._v(" "),_("li",[t._v("no-transform > 告知客户端缓存文件时不得对实体数据做任何更改")]),t._v(" "),_("li",[t._v("max-age=delta-seconds > 告知客户端该资源在delta-seconds秒内是新鲜的，无需向服务器发送请求")])])])]),t._v(" "),_("h2",{attrs:{id:"协商缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),_("p",[t._v("若未命中强缓存，则浏览器会将请求发送至服务器。服务器根据http头信息中的Last-Modify/If-Modify-Since或Etag/If-None-Match来判断是否命中协商缓存。如果命中，则http返回码为304，浏览器从缓存中加载资源。")]),t._v(" "),_("h2",{attrs:{id:"last-modified"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#last-modified"}},[t._v("#")]),t._v(" Last-Modified")]),t._v(" "),_("ul",[_("li",[t._v("表示资源的最后更改时间，服务器将资源传递给客户端时，会将资源的最后更改时间以："),_("code",[t._v("Last-Modified: GMT")]),t._v(" 的形式加在实体首部上一起返回给客户端")]),t._v(" "),_("li",[t._v("客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回304状态码")])]),t._v(" "),_("h3",{attrs:{id:"if-modified-since"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#if-modified-since"}},[t._v("#")]),t._v(" If-Modified-Since")]),t._v(" "),_("blockquote",[_("p",[t._v("示例：If-Modified-Since: Wed, 24 Jun 2020 03:33:06 GMT")])]),t._v(" "),_("p",[t._v("该请求首部告诉服务器如果客户端传来的最后修改时间与服务器上的一致，则直接回送304 和响应报头即可。")]),t._v(" "),_("h3",{attrs:{id:"if-unmodified-since"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#if-unmodified-since"}},[t._v("#")]),t._v(" If-Unmodified-Since")]),t._v(" "),_("blockquote",[_("p",[t._v("告诉服务器，若Last-Modified没有匹配上（资源在服务端的最后更新时间改变了），则应当返回412(Precondition Failed) 状态码给客户端。")])]),t._v(" "),_("p",[t._v("当遇到下面情况时，If-Unmodified-Since 字段会被忽略")]),t._v(" "),_("ul",[_("li",[t._v("Last-Modified值对上了（资源在服务端没有新的修改）")]),t._v(" "),_("li",[t._v("服务端需返回2XX和412之外的状态码")]),t._v(" "),_("li",[t._v("传来的指定日期不合法")])]),t._v(" "),_("h2",{attrs:{id:"etag"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#etag"}},[t._v("#")]),t._v(" ETag")]),t._v(" "),_("ul",[_("li",[t._v("服务器会通过某种算法，给资源计算出一个唯一标志（比如md5标志），在把资源响应给客户端的时候，会在实体首部加上“ETag: 唯一标识符”一起返回给客户端")]),t._v(" "),_("li",[t._v("客户端会保留该 ETag 字段，并在下一次请求时将其一并带过去给服务器。服务器只需要比较客户端传来的ETag跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了")]),t._v(" "),_("li",[t._v("如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。")])]),t._v(" "),_("h3",{attrs:{id:"if-none-match"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#if-none-match"}},[t._v("#")]),t._v(" If-None-Match")]),t._v(" "),_("blockquote",[_("p",[t._v('示例为 If-None-Match: "56fcccc8-1699"')])]),t._v(" "),_("p",[t._v("告诉服务端如果 ETag 没匹配上需要重发资源数据，否则直接回送304 和响应报头")]),t._v(" "),_("h3",{attrs:{id:"if-match"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#if-match"}},[t._v("#")]),t._v(" If-Match")]),t._v(" "),_("p",[t._v("告诉服务器如果没有匹配到ETag，或者收到了“*”值而当前并没有该资源实体，则应当返回412(Precondition Failed) 状态码给客户端。否则服务器直接忽略该字段")]),t._v(" "),_("blockquote",[_("p",[t._v("如果 Last-Modified 和 ETag 同时被使用，则要求它们的验证都必须通过才会返回304，若其中某个验证没通过，则服务器会按常规返回资源实体及200状态码")])]),t._v(" "),_("h2",{attrs:{id:"如何保证客户端及时更新缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何保证客户端及时更新缓存"}},[t._v("#")]),t._v(" 如何保证客户端及时更新缓存")]),t._v(" "),_("p",[t._v("通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源。常用更新方法如下：")]),t._v(" "),_("ol",[_("li",[t._v("用数字做版本号")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('<link href="a.css?v=1.0.1">\n')])])]),_("p",[t._v("但是如果使用版本号的话，假如每次只更新一个文件，其他未更改的文件为了保持版本一致都需要更新，所以不推荐用版本号。")]),t._v(" "),_("ol",[_("li",[t._v("用文件摘要做版本号\n另一种办法就是采用"),_("strong",[t._v("数据摘要要算法")]),t._v("对文件求摘要值，拼接到路径参数上，更新某一文件时，只需更新对应文件的路径即可。如下：")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('<link href="a.css?v=0cadf2356">\n')])])]),_("p",[t._v("但这样有一个问题：\n更新对应文件时，html 中的引用路径也需要修改，"),_("strong",[t._v("先部署页面？还是先部署静态资源？")])]),t._v(" "),_("p",[_("strong",[t._v("先部署页面")]),t._v("，在两者部署间隔中，假如有用户访问新页面，此时"),_("strong",[t._v("页面中的资源路径已经更新，但资源仍未更新")]),t._v("。客户端看到这个新的路径，就会发起请求，然而依然会拿到旧资源并作为缓存，并且，即便后面资源更新了，在已拿到资源缓存过期前，一直都不会重新请求，"),_("strong",[t._v("一直都会是旧资源")])]),t._v(" "),_("p",[_("strong",[t._v("先部署资源")]),t._v("，在两者部署间隔中，假如有用户访问，此时 html 中资源路径仍未更新，资源已经更新。这时假如本地缓存未过期，则不会请求，一切安好。假如这时本地缓存过期了，会去协商缓存，就会出现"),_("strong",[t._v("旧 html 引用新资源的情况，可能会导致页面出错")]),t._v("。")]),t._v(" "),_("h2",{attrs:{id:"已有缓存实现的对比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#已有缓存实现的对比"}},[t._v("#")]),t._v(" 已有缓存实现的对比")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("头部")]),t._v(" "),_("th",[t._v("优势和特点")]),t._v(" "),_("th",[t._v("劣势和问题")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("Expires")]),t._v(" "),_("td",[t._v("1、HTTP 1.0 产物，可以在HTTP 1.0和1.1中使用，简单易用。 2、以时刻标识失效时间。")]),t._v(" "),_("td",[t._v("1、时间是由服务器发送的(UTC)，如果服务器时间和客户端时间存在不一致，可能会出现问题。 2、存在版本问题，到期之前的修改客户端是不可知的。")])]),t._v(" "),_("tr",[_("td",[t._v("Cache-Control")]),t._v(" "),_("td",[t._v("1、HTTP 1.1 产物，以时间间隔标识失效时间，解决了Expires服务器和客户端相对时间的问题。 2、比Expires多了很多选项设置。")]),t._v(" "),_("td",[t._v("1、HTTP 1.1 才有的内容，不适用于HTTP 1.0 。 2、存在版本问题，到期之前的修改客户端是不可知的。")])]),t._v(" "),_("tr",[_("td",[t._v("Last-Modified")]),t._v(" "),_("td",[t._v("1、不存在版本问题，每次请求都会去服务器进行校验。服务器对比最后修改时间如果相同则返回304，不同返回200以及资源内容。")]),t._v(" "),_("td",[t._v("1、只要资源修改，无论内容是否发生实质性的变化，都会将该资源返回客户端。例如周期性重写，这种情况下该资源包含的数据实际上一样的。 2、以时刻作为标识，无法识别一秒内进行多次修改的情况。 3、某些服务器不能精确的得到文件的最后修改时间。")])]),t._v(" "),_("tr",[_("td",[t._v("ETag")]),t._v(" "),_("td",[t._v("1、可以更加精确的判断资源是否被修改，可以识别一秒内多次修改的情况。 2、不存在版本问题，每次请求都会去服务器进行校验。")]),t._v(" "),_("td",[t._v("1、计算ETag值需要性能损耗。 2、分布式服务器存储的情况下，计算ETag的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时发现ETag不匹配的情况。")])])])]),t._v(" "),_("h2",{attrs:{id:"用户操作行为与缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#用户操作行为与缓存"}},[t._v("#")]),t._v(" 用户操作行为与缓存")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("用户操作")]),t._v(" "),_("th",[t._v("Expires/Cache-Control")]),t._v(" "),_("th",[t._v("Last-Modified/Etag")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("地址栏回车")]),t._v(" "),_("td",[t._v("有效")]),t._v(" "),_("td",[t._v("有效")])]),t._v(" "),_("tr",[_("td",[t._v("页面链接跳转")]),t._v(" "),_("td",[t._v("有效")]),t._v(" "),_("td",[t._v("有效")])]),t._v(" "),_("tr",[_("td",[t._v("新开窗口")]),t._v(" "),_("td",[t._v("有效")]),t._v(" "),_("td",[t._v("有效")])]),t._v(" "),_("tr",[_("td",[t._v("前进后退")]),t._v(" "),_("td",[t._v("有效")]),t._v(" "),_("td",[t._v("有效")])]),t._v(" "),_("tr",[_("td",[t._v("F5刷新")]),t._v(" "),_("td",[t._v("无效")]),t._v(" "),_("td",[t._v("有效")])]),t._v(" "),_("tr",[_("td",[t._v("CTRL+F5强刷新")]),t._v(" "),_("td",[t._v("无效")]),t._v(" "),_("td",[t._v("无效")])])])]),t._v(" "),_("p",[_("strong",[t._v("浏览器中的操作对缓存的影响")]),t._v(":")]),t._v(" "),_("ul",[_("li",[t._v("强制刷新 – 当按下ctrl+F5来刷新页面的时候, 浏览器将绕过各种缓存(本地缓存和协商缓存), 直接让服务器返回最新的资源;")]),t._v(" "),_("li",[t._v("普通刷新 – 当按下F5来刷新页面的时候,浏览器将绕过本地缓存来发送请求到服务器, 此时, 协商缓存是有效的")]),t._v(" "),_("li",[t._v("回车或转向 – 当在地址栏上输入回车或者按下跳转按钮的时候, 所有缓存都生效")])])])}),[],!1,null,null,null);a.default=e.exports}}]);