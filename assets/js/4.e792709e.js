(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{263:function(t,_,v){t.exports=v.p+"assets/img/tcp-connection-made-three-way-handshake.dc84424c.png"},264:function(t,_,v){t.exports=v.p+"assets/img/tcp-buffer.bce3ff4e.jpg"},265:function(t,_,v){t.exports=v.p+"assets/img/tcp-sliding-window.03bb82da.jpg"},266:function(t,_,v){t.exports=v.p+"assets/img/tcp-sliding-processes.d3037487.jpg"},267:function(t,_,v){t.exports=v.p+"assets/img/tcp-retransmission.5fb7259a.jpg"},268:function(t,_,v){t.exports=v.p+"assets/img/tcp-connection-closed-four-way-handshake.69f6d366.png"},306:function(t,_,v){"use strict";v.r(_);var a=v(38),r=Object(a.a)({},function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"tcp协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp协议","aria-hidden":"true"}},[t._v("#")]),t._v(" "),a("center",[t._v("TCP协议")])],1),t._v(" "),a("h3",{attrs:{id:"tcp-的特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp-的特性","aria-hidden":"true"}},[t._v("#")]),t._v(" TCP 的特性")]),t._v(" "),a("ul",[a("li",[t._v("TCP 提供一种"),a("strong",[t._v("面向连接")]),t._v("的、"),a("strong",[t._v("可靠")]),t._v("的字节流服务")]),t._v(" "),a("li",[t._v("在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP")]),t._v(" "),a("li",[t._v("TCP 使用校验和，确认和重传机制来保证可靠传输")]),t._v(" "),a("li",[t._v("TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复")]),t._v(" "),a("li",[t._v("TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制")])]),t._v(" "),a("p",[a("strong",[t._v("注意")]),t._v("：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。")]),t._v(" "),a("h2",{attrs:{id:"三次握手-建立链接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三次握手-建立链接","aria-hidden":"true"}},[t._v("#")]),t._v(" 三次握手-建立链接")]),t._v(" "),a("p",[t._v("所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。")]),t._v(" "),a("p",[t._v("三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("第一次握手(SYN=1, seq=x):")]),t._v(" "),a("p",[t._v("客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。")]),t._v(" "),a("p",[t._v("发送完毕后，客户端进入 SYN_SEND 状态。")])]),t._v(" "),a("li",[a("p",[t._v("第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):")]),t._v(" "),a("p",[t._v("服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端初始化自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。")])]),t._v(" "),a("li",[a("p",[t._v("第三次握手(ACK=1，ACKnum=y+1)")]),t._v(" "),a("p",[t._v("客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1")]),t._v(" "),a("p",[t._v("发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。")])])]),t._v(" "),a("p",[t._v("三次握手的过程的示意图如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:v(263),alt:"sss"}})]),t._v(" "),a("h3",{attrs:{id:"为什么是三次握手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么是三次握手","aria-hidden":"true"}},[t._v("#")]),t._v(" 为什么是三次握手")]),t._v(" "),a("ul",[a("li",[t._v("tcp连接是全双工的，数据在两个方向上能同时传递。")]),t._v(" "),a("li",[t._v("所以要确保双方，同时能发数据和收数据")]),t._v(" "),a("li",[t._v("第一次握手：证明了发送方能发数据")]),t._v(" "),a("li",[t._v("第二次握手：ack确保了接收方能收数据，syn确保了接收方能发数据")]),t._v(" "),a("li",[t._v("第三次握手：确保了发送方能收数据")]),t._v(" "),a("li",[t._v("实际上是四个维度的信息交换，不过中间两步合并为一次握手了。")]),t._v(" "),a("li",[t._v("四次握手浪费，两次握手不能保证“双方同时具备收发功能”")])]),t._v(" "),a("p",[t._v("为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。")]),t._v(" "),a("h3",{attrs:{id:"序列号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#序列号","aria-hidden":"true"}},[t._v("#")]),t._v(" 序列号")]),t._v(" "),a("p",[t._v("在上文中提到的初始化 "),a("strong",[t._v("序列号")]),t._v(" (英文为：Initial Sequence Number，简称"),a("strong",[t._v("ISN")]),t._v(");")]),t._v(" "),a("p",[t._v("TCP初始化序列号不能设置为一个固定值，因为这样容易被攻击者猜出后续序列号，从而遭到攻击。")]),t._v(" "),a("p",[t._v("RFC1948中提出了一个较好的初始化序列号ISN随机生成算法。")]),t._v(" "),a("p",[a("strong",[a("center",[t._v("ISN = M + F(localhost, localport, remotehost, remoteport)")])],1)]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("M")]),t._v("是一个计时器，这个计时器每隔4毫秒加1。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("F")]),t._v("是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出，用"),a("strong",[t._v("MD5")]),t._v("算法是一个比较好的选择。")])])]),t._v(" "),a("h4",{attrs:{id:"初始化序列号的目的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#初始化序列号的目的","aria-hidden":"true"}},[t._v("#")]),t._v(" 初始化序列号的目的")]),t._v(" "),a("p",[t._v("由于A和B之间的一个tcp连接通常是由A和B的2个ip地址，2个端口号构成的四元组，因此当A出现了故障把这个tcp连接断开了，之后再以相同的四元组建立新的tcp连接（也就是说A和B两次建立tcp连接都是使用了相同的ip地址和端口），就会出现数据乱序的问题。")]),t._v(" "),a("p",[t._v("换句话说，只要A发送了一个tcp报文段，且这个tcp报文段的四元组和序号，和之前的tcp连接（四元组和序号）相同的话，就会被B确认。这其实反映了tcp的一些缺点，如果被一些恶意攻击者加以利用tcp的这种缺点：选择合适的序号，ip地址和端口的话，就能伪造出一个tcp报文段，从而打断正常的tcp连接。但是初始化序号的方式（通过算法来随机生成序号）就会使序号难以猜出，也就不容易利用这种缺点来进行一些恶意攻击行为。")]),t._v(" "),a("p",[t._v("通过上面所述我们知道，如果A和B之间发送数据每次都使用相同序号的话可能会引发一系列的问题，但是使用不同序号的话，那么B在接收到这个序号为1的tcp报文时，发现这个tcp报文的序号不在新tcp连接的接收范围内时会把这个tcp报文丢弃掉，也就避免了数据乱序的问题。")]),t._v(" "),a("p",[t._v("因此我们可以明白，客户端和服务端双方在建立tcp连接并初始化序列号，那么上面所说的这些情况从一开始就可以避免。另外，tcp在初始化序列号的过程也是比较复杂的，一般来说，这个序号的范围是0 ~ 2^31之间，而且序号的生成也是随机的，通常是一个很大的数值，也就是说每个tcp连接使用的序号也是不一样的。")]),t._v(" "),a("h3",{attrs:{id:"tcp-缓冲区的数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp-缓冲区的数据结构","aria-hidden":"true"}},[t._v("#")]),t._v(" TCP 缓冲区的数据结构")]),t._v(" "),a("p",[a("img",{attrs:{src:v(264),alt:"数据结构图"}})]),t._v(" "),a("ul",[a("li",[a("p",[t._v("接收端：")]),t._v(" "),a("ul",[a("li",[t._v("LastByteRead: 缓冲区读取到的位置")]),t._v(" "),a("li",[t._v("NextByteExpected：收到的连续包的最后一个位置")]),t._v(" "),a("li",[t._v("LastByteRcvd：收到的包的最后一个位置")]),t._v(" "),a("li",[t._v("中间空白区：数据没有到达")])])]),t._v(" "),a("li",[a("p",[t._v("发送端：")]),t._v(" "),a("ul",[a("li",[t._v("LastByteAcked: 被接收端ack的位置，表示成功发送确认")]),t._v(" "),a("li",[t._v("LastByteSent：发出去了，还没有收到成功确认的Ack")]),t._v(" "),a("li",[t._v("LastByteWritten：上层应用正在写的地方")])])])]),t._v(" "),a("h3",{attrs:{id:"滑动窗口示意图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口示意图","aria-hidden":"true"}},[t._v("#")]),t._v(" 滑动窗口示意图")]),t._v(" "),a("h4",{attrs:{id:"滑动初始示意图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#滑动初始示意图","aria-hidden":"true"}},[t._v("#")]),t._v(" 滑动初始示意图")]),t._v(" "),a("p",[a("img",{attrs:{src:v(265),alt:"初始示意图"}})]),t._v(" "),a("ul",[a("li",[t._v("黑框表示滑动窗口")]),t._v(" "),a("li",[t._v("'#1'表示收到ack确认的数据")]),t._v(" "),a("li",[t._v("'#2'表示还没收到ack的数据")]),t._v(" "),a("li",[t._v("'#3'表示在窗口中还没有发出的（接收方还有空间）")]),t._v(" "),a("li",[t._v("'#4'窗口以外的数据（接收方没空间）")])]),t._v(" "),a("h4",{attrs:{id:"滑动过程示意图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#滑动过程示意图","aria-hidden":"true"}},[t._v("#")]),t._v(" 滑动过程示意图")]),t._v(" "),a("p",[a("img",{attrs:{src:v(266),alt:"滑动过程"}})]),t._v(" "),a("ul",[a("li",[t._v("收到36的ack，并发出46-51的字节")])]),t._v(" "),a("h4",{attrs:{id:"拥塞窗口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拥塞窗口","aria-hidden":"true"}},[t._v("#")]),t._v(" 拥塞窗口")]),t._v(" "),a("ul",[a("li",[t._v("解决什么问题：发送方发送速度过快，导致中转路由器拥堵的问题")]),t._v(" "),a("li",[t._v("机制：发送方增加一个拥塞窗口（cwnd），每次受到ack，窗口值加1。发送时，取拥塞窗口和接收方发来的窗口大小取最小值发送")]),t._v(" "),a("li",[t._v("起到发送方流量控制的作用")])]),t._v(" "),a("h4",{attrs:{id:"滑动窗口会引发的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口会引发的问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 滑动窗口会引发的问题")]),t._v(" "),a("h5",{attrs:{id:"零窗口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#零窗口","aria-hidden":"true"}},[t._v("#")]),t._v(" 零窗口")]),t._v(" "),a("ul",[a("li",[t._v("如何发生： 接收端处理速度慢，发送端发送速度快。窗口大小慢慢被调为0")]),t._v(" "),a("li",[t._v("如何解决：ZWP技术。发送zwp包给接收方，让接收方ack他的窗口大小。")])]),t._v(" "),a("h4",{attrs:{id:"糊涂窗口综合征"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#糊涂窗口综合征","aria-hidden":"true"}},[t._v("#")]),t._v(" 糊涂窗口综合征")]),t._v(" "),a("ul",[a("li",[t._v("如何发生：接收方太忙，取不完数据，导致发送方越来越小。最后只让发送方传几字节的数据。")]),t._v(" "),a("li",[t._v("缺点：数据比tcp和ip头小太多，网络利用率太低。")]),t._v(" "),a("li",[t._v("如何解决：避免对小的窗口大小做响应。\n"),a("ul",[a("li",[t._v("发送端：前面说到的Nagle算法。")]),t._v(" "),a("li",[t._v("接收端：窗口大小小于某个值，直接ack（0），阻止发送数据。窗口变大后再发。")])])])]),t._v(" "),a("h3",{attrs:{id:"超时重传机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#超时重传机制","aria-hidden":"true"}},[t._v("#")]),t._v(" 超时重传机制")]),t._v(" "),a("p",[t._v("####背景")]),t._v(" "),a("ul",[a("li",[t._v("接收端给发送端的Ack确认只会确认最后一个连续的包")]),t._v(" "),a("li",[t._v("比如发送1,2,3,4,5共五份数据，接收端收到1,2，于是回ack3，然后收到4（还没收到3），此时tcp不会跳过3直接确认4，否则发送端以为3也收到了。这时你能想到的方法是什么呢？tcp又是怎么处理的呢？")])]),t._v(" "),a("h4",{attrs:{id:"被动等待的超时重传策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#被动等待的超时重传策略","aria-hidden":"true"}},[t._v("#")]),t._v(" 被动等待的超时重传策略")]),t._v(" "),a("ul",[a("li",[t._v("直观的方法是：接收方不做任何处理，等待发送方超时，然后重传。\n"),a("ul",[a("li",[t._v("缺点：发送端不知道该重发3，还是重发3,4,5")])])]),t._v(" "),a("li",[t._v("如果发送方如果只发送3：节省宽度，但是慢")]),t._v(" "),a("li",[t._v("如果发送方如果发送3,4,5：快，但是浪费宽带")]),t._v(" "),a("li",[t._v("总之，都在被动等待超时，超时可能很长。所以tcp不采用此方法")])]),t._v(" "),a("h4",{attrs:{id:"主动的快速重传机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主动的快速重传机制","aria-hidden":"true"}},[t._v("#")]),t._v(" 主动的快速重传机制")]),t._v(" "),a("p",[t._v("英文名为：Fast Retransmit, 不以实际驱动，而以数据驱动重传")]),t._v(" "),a("h5",{attrs:{id:"实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现原理","aria-hidden":"true"}},[t._v("#")]),t._v(" 实现原理")]),t._v(" "),a("ul",[a("li",[t._v("如果包没有送达，就一直ack最后那个可能被丢的包")]),t._v(" "),a("li",[t._v("发送方连续收到3相同的ack，就重传。不用等待超时")])]),t._v(" "),a("p",[a("img",{attrs:{src:v(267),alt:"tcp-重传"}})]),t._v(" "),a("ul",[a("li",[t._v("图中发生1,2,3,4,5数据")]),t._v(" "),a("li",[t._v("数据1到达，发生ack2")]),t._v(" "),a("li",[t._v("数据2因为某些原因没有送到")]),t._v(" "),a("li",[t._v("后续收到3的时候，接收端并不是ack4，也不是等待。而是主动ack2")]),t._v(" "),a("li",[t._v("收到4,5同理，一直主动ack2")]),t._v(" "),a("li",[t._v("客户端收到三次ack2，就重传2")]),t._v(" "),a("li",[t._v("2收到后，结合之前收到的3,4,5，直接ack6")])]),t._v(" "),a("h5",{attrs:{id:"快速重传的利弊"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#快速重传的利弊","aria-hidden":"true"}},[t._v("#")]),t._v(" 快速重传的利弊")]),t._v(" "),a("ul",[a("li",[t._v("解决了被动等待timeout的问题")]),t._v(" "),a("li",[t._v("无法解决重传之前的一个，还是所有的问题。")]),t._v(" "),a("li",[t._v("上面的例子中是重传2，还是重传2,3,4,5。因为并不清楚ack2是谁传回来的")])]),t._v(" "),a("h4",{attrs:{id:"sack方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sack方法","aria-hidden":"true"}},[t._v("#")]),t._v(" SACK方法")]),t._v(" "),a("ul",[a("li",[t._v("为了解决快速重传的缺点，一种更好的SACK重传策略被提出")]),t._v(" "),a("li",[t._v("基于快速重传，同时在tcp头里加了一个SACK的东西")]),t._v(" "),a("li",[t._v("解决了什么问题：客户端应该发送哪些超时包的问题")])]),t._v(" "),a("h5",{attrs:{id:"实现原理-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现原理-2","aria-hidden":"true"}},[t._v("#")]),t._v(" 实现原理")]),t._v(" "),a("ul",[a("li",[t._v("SACK记录一个数值范围，表示哪些数据收到了")]),t._v(" "),a("li",[t._v("linux2.4后默认打开该功能，之前版本需要配置tcp-sack参数")]),t._v(" "),a("li",[t._v("SACK只是一种辅助的方式，发送方不能完全依赖SACK。主要还是依赖ACK和timout")])]),t._v(" "),a("h5",{attrs:{id:"duplicate-sack-d-sack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#duplicate-sack-d-sack","aria-hidden":"true"}},[t._v("#")]),t._v(" Duplicate SACK(D-SACK)")]),t._v(" "),a("ul",[a("li",[t._v("使用SACK标识的范围，还可以知道告知发送方，有哪些数据被重复接收了")]),t._v(" "),a("li",[t._v("可以让发送方知道：是发出去的包丢了，还是回来的ack包丢了")])]),t._v(" "),a("h3",{attrs:{id:"超时时间的确定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#超时时间的确定","aria-hidden":"true"}},[t._v("#")]),t._v(" 超时时间的确定")]),t._v(" "),a("h4",{attrs:{id:"背景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#背景","aria-hidden":"true"}},[t._v("#")]),t._v(" 背景")]),t._v(" "),a("ul",[a("li",[t._v("路由器和网络流量均会变化")]),t._v(" "),a("li",[t._v("所以超时时间肯定不能设置为一个固定值")]),t._v(" "),a("li",[t._v("超时长：重发慢，效率低，性能差")]),t._v(" "),a("li",[t._v("超时短：并没有丢就重发，导致网络拥塞，导致更多超时和更多重发")]),t._v(" "),a("li",[t._v("tcp会追踪这些变化，并相应的动态改变超时时间（RTO）")])]),t._v(" "),a("h4",{attrs:{id:"如何动态改变"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何动态改变","aria-hidden":"true"}},[t._v("#")]),t._v(" 如何动态改变")]),t._v(" "),a("ul",[a("li",[t._v("每次重传的时间间隔为上次的一倍，直到最大间隔为64s，称为“指数退避”")]),t._v(" "),a("li",[t._v("首次重传到最后放弃重传的时间间隔一般为9min")]),t._v(" "),a("li",[t._v("依赖以往的往返时间计算（RTT）动态的计算")])]),t._v(" "),a("h4",{attrs:{id:"往返时间（rtt）的计算方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#往返时间（rtt）的计算方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 往返时间（RTT）的计算方法")]),t._v(" "),a("ul",[a("li",[t._v("并不是简单的ack时间和发送时间的差值。因为有重传，网络阻塞等各种变化的因素。")]),t._v(" "),a("li",[t._v("而是通过采样多次数值，然后做估算")]),t._v(" "),a("li",[t._v("tcp使用的方法有：\n"),a("ul",[a("li",[t._v("被平滑的RTT估计器")]),t._v(" "),a("li",[t._v("被平滑的均值偏差估计器")])])])]),t._v(" "),a("h4",{attrs:{id:"重传时间的具体计算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重传时间的具体计算","aria-hidden":"true"}},[t._v("#")]),t._v(" 重传时间的具体计算")]),t._v(" "),a("ul",[a("li",[t._v("计算往返时间（RTT），保存测量结果")]),t._v(" "),a("li",[t._v("通过测量结果维护一个被平滑的RTT估计器和被平滑的均值偏差估计器")]),t._v(" "),a("li",[t._v("根据这两个估计器计算下一次重传时间")])]),t._v(" "),a("h3",{attrs:{id:"超时重传引发的问题-拥塞"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#超时重传引发的问题-拥塞","aria-hidden":"true"}},[t._v("#")]),t._v(" 超时重传引发的问题-拥塞")]),t._v(" "),a("h4",{attrs:{id:"为什么重传会引发拥塞"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么重传会引发拥塞","aria-hidden":"true"}},[t._v("#")]),t._v(" 为什么重传会引发拥塞")]),t._v(" "),a("ul",[a("li",[t._v("当网络延迟突然增加时，tcp会重传数据")]),t._v(" "),a("li",[t._v("但是过多的重传会导致网络负担加重，从而导致更大的延时和丢包，进入恶性循环")]),t._v(" "),a("li",[t._v("也就是tcp的拥塞问题")])]),t._v(" "),a("h4",{attrs:{id:"解决拥塞-拥塞控制的算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决拥塞-拥塞控制的算法","aria-hidden":"true"}},[t._v("#")]),t._v(" 解决拥塞-拥塞控制的算法")]),t._v(" "),a("ul",[a("li",[t._v("慢启动：降低分组进入网络的传输速率")]),t._v(" "),a("li",[t._v("拥塞避免：处理丢失分组的算法")]),t._v(" "),a("li",[t._v("快速重传")]),t._v(" "),a("li",[t._v("快速恢复")])]),t._v(" "),a("h2",{attrs:{id:"四次挥手-关闭链接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手-关闭链接","aria-hidden":"true"}},[t._v("#")]),t._v(" 四次挥手-关闭链接")]),t._v(" "),a("p",[t._v("TCP 的连接的关闭需要发送四个包，因此称为"),a("strong",[t._v("四次挥手")]),t._v("(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("第一次挥手(FIN=1，seq=x)")]),t._v(" "),a("p",[t._v("假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。")]),t._v(" "),a("p",[t._v("发送完毕后，客户端进入 FIN_WAIT_1 状态。")])]),t._v(" "),a("li",[a("p",[t._v("第二次挥手(ACK=1，ACKnum=x+1)")]),t._v(" "),a("p",[t._v("服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。")]),t._v(" "),a("p",[t._v("发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。")])]),t._v(" "),a("li",[a("p",[t._v("第三次挥手(FIN=1，seq=y)")]),t._v(" "),a("p",[t._v("服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。")]),t._v(" "),a("p",[t._v("发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。")])]),t._v(" "),a("li",[a("p",[t._v("第四次挥手(ACK=1，ACKnum=y+1)")]),t._v(" "),a("p",[t._v("客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。")]),t._v(" "),a("p",[t._v("服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。")]),t._v(" "),a("p",[t._v("客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。")])])]),t._v(" "),a("p",[t._v("四次挥手的示意图如下：\n"),a("img",{attrs:{src:v(268),alt:"四次挥手"}})]),t._v(" "),a("h3",{attrs:{id:"为什么是四次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么是四次挥手","aria-hidden":"true"}},[t._v("#")]),t._v(" 为什么是四次挥手")]),t._v(" "),a("ul",[a("li",[t._v("因为tcp连接是全双工的，数据在两个方向上能同时传递。")]),t._v(" "),a("li",[t._v("同时tcp支持半关闭（发送一方结束发送还能接收数据的功能）。")]),t._v(" "),a("li",[t._v("因此每个方向都要单独关闭，且收到关系通知需要发送确认回复。")])]),t._v(" "),a("h4",{attrs:{id:"为什么要支持半关闭"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要支持半关闭","aria-hidden":"true"}},[t._v("#")]),t._v(" 为什么要支持半关闭")]),t._v(" "),a("ul",[a("li",[t._v("客户端需要通知服务端，它的数据已经传输完毕")]),t._v(" "),a("li",[t._v("同时仍要接收来自服务端的数据")]),t._v(" "),a("li",[t._v("使用半关闭的单连接效率要比使用两个tcp连接更好")])]),t._v(" "),a("h2",{attrs:{id:"tcp-keepalive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp-keepalive","aria-hidden":"true"}},[t._v("#")]),t._v(" TCP KeepAlive")]),t._v(" "),a("p",[t._v("TCP 的连接，实际上是一种纯软件层面的概念，在物理层面并没有“连接”这种概念。TCP 通信双方建立交互的连接，但是并不是一直存在数据交互，有些连接会在数据交互完毕后，主动释放连接，而有些不会。在长时间无数据交互的时间段内，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些 TCP 连接并未来得及正常释放，在软件层面上，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用 TCP 的 KeepAlive 机制实现来实现。主流的操作系统基本都在内核里支持了这个特性。")]),t._v(" "),a("p",[t._v("TCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。")])])},[],!1,null,null,null);_.default=r.exports}}]);