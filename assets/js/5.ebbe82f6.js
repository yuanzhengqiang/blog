(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{400:function(t,e,a){t.exports=a.p+"assets/img/rendering-flowchart.faf0dae9.png"},401:function(t,e,a){t.exports=a.p+"assets/img/static-rendering.f7d2bac7.jpg"},402:function(t,e,a){t.exports=a.p+"assets/img/rendering-layout.df0a3653.jpg"},403:function(t,e,a){t.exports=a.p+"assets/img/rendering-paint.ce082e7c.jpg"},404:function(t,e,a){t.exports=a.p+"assets/img/rendering-raster.df88b1cd.jpg"},405:function(t,e,a){t.exports=a.p+"assets/img/rendering-frame.4caa3701.jpg"},406:function(t,e,a){t.exports=a.p+"assets/img/rendering-invalidation.9e04a3ed.jpg"},407:function(t,e,a){t.exports=a.p+"assets/img/rendering-compositing.2dcae325.jpg"},408:function(t,e,a){t.exports=a.p+"assets/img/rendering-layer.47621637.jpg"},409:function(t,e,a){t.exports=a.p+"assets/img/rendering-layer-tree.5122f10c.jpg"},410:function(t,e,a){t.exports=a.p+"assets/img/tiling-drawing.d489c9ca.jpg"},411:function(t,e,a){t.exports=a.p+"assets/img/rendering-activation.cd61860f.jpg"},412:function(t,e,a){t.exports=a.p+"assets/img/rendering-display.90f07c05.jpg"},464:function(t,e,a){"use strict";a.r(e);var r=a(43),v=Object(r.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"渲染过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#渲染过程"}},[t._v("#")]),t._v(" "),r("center",[t._v("渲染过程")])],1),t._v(" "),r("p",[t._v("渲染进程几乎负责 Tab 内的所有事情，渲染进程的核心目的在于转换 HTML CSS JS 为用户可交互的 web 页面。渲染进程中主要包含以下线程：")]),t._v(" "),r("ul",[r("li",[t._v("主线程 Main thread")]),t._v(" "),r("li",[t._v("工作线程 Worker thread")]),t._v(" "),r("li",[t._v("排版线程 Compositor thread")]),t._v(" "),r("li",[t._v("光栅线程 Raster thread")])]),t._v(" "),r("p",[t._v("接下来我们看下渲染过程:")]),t._v(" "),r("p",[t._v("1."),r("strong",[t._v("构建 DOM")])]),t._v(" "),r("p",[t._v("当渲染进程接收到导航的确认信息，开始接受 HTML 数据时，主线程会解析文本字符串为 DOM。")]),t._v(" "),r("p",[t._v("渲染 html 为 DOM 的方法由 HTML Standard 定义。")]),t._v(" "),r("p",[t._v("2."),r("strong",[t._v("加载次级的资源")])]),t._v(" "),r("p",[t._v("网页中常常包含诸如图片，CSS，JS 等额外的资源，这些资源需要从网络上或者 cache 中获取。主进程可以在构建 DOM 的过程中会逐一请求它们，为了加速 preload scanner 会同时运行，如果在 html 中存在 "),r("code",[t._v("<img>")]),t._v(" "),r("code",[t._v("<link>")]),t._v(" 等标签，preload scanner 会把这些请求传递给 Browser process 中的 network thread 进行相关资源的下载。")]),t._v(" "),r("p",[t._v("3."),r("strong",[t._v("JS 的下载与执行")])]),t._v(" "),r("p",[t._v("当遇到 "),r("code",[t._v("<script>")]),t._v(" 标签时，渲染进程会停止解析 HTML，而去加载，解析和执行 JS 代码，停止解析 html 的原因在于 JS 可能会改变 DOM 的结构（使用诸如 "),r("code",[t._v("document.write()")]),t._v("等API）。")]),t._v(" "),r("p",[t._v("不过开发者其实也有多种方式来告知浏览器应对如何应对某个资源，比如说如果在"),r("code",[t._v("<script>")]),t._v(" 标签上添加了 "),r("code",[t._v("async")]),t._v(" 或 "),r("code",[t._v("defer")]),t._v(" 等属性，浏览器会异步的加载和执行JS代码，而不会阻塞渲染。")]),t._v(" "),r("p",[t._v("4."),r("strong",[t._v("样式计算")])]),t._v(" "),r("p",[t._v("仅仅渲染 DOM 还不足以获知页面的具体样式，主进程还会基于 CSS 选择器解析 CSS 获取每一个节点的最终的计算样式值。即使不提供任何 CSS，浏览器对每个元素也会有一个默认的样式。")]),t._v(" "),r("p",[t._v("5."),r("strong",[t._v("获取布局")])]),t._v(" "),r("p",[t._v("想要渲染一个完整的页面，除了获知每个节点的具体样式，还需要获知每一个节点在页面上的位置，布局其实是找到所有元素的几何关系的过程。其具体过程如下：")]),t._v(" "),r("p",[t._v("通过遍历 DOM 及相关元素的计算样式，主线程会构建出包含每个元素的坐标信息及盒子大小的布局树。布局树和 DOM 树类似，但是其中只包含页面可见的元素，如果一个元素设置了 "),r("code",[t._v("display:none")]),t._v(" ，这个元素不会出现在布局树上，伪元素虽然在 DOM 树上不可见，但是在布局树上是可见的。")]),t._v(" "),r("p",[t._v("6."),r("strong",[t._v("绘制各元素")])]),t._v(" "),r("p",[t._v("即使知道了不同元素的位置及样式信息，我们还需要知道不同元素的绘制先后顺序才能正确绘制出整个页面。在绘制阶段，主线程会遍历布局树以创建绘制记录。绘制记录可以看做是记录各元素绘制先后顺序的笔记。")]),t._v(" "),r("p",[t._v("7."),r("strong",[t._v("合成帧")])]),t._v(" "),r("p",[t._v("熟悉 PS 等绘图软件的童鞋肯定对图层这一概念不陌生，现代 Chrome 其实利用了这一概念来组合不同的层。")]),t._v(" "),r("p",[t._v("复合是一种分割页面为不同的层，并单独栅格化，随后组合为帧的技术。不同层的组合由 compositor 线程（合成器线程）完成。")]),t._v(" "),r("p",[t._v("主线程会遍历布局树来创建层树（layer tree），添加了 "),r("code",[t._v("will-change")]),t._v(" CSS 属性的元素，会被看做单独的一层;")]),t._v(" "),r("p",[t._v("你可能会想给每一个元素都添加上 "),r("code",[t._v("will-change")]),t._v("，不过组合过多的层也许会比在每一帧都栅格化页面中的某些小部分更慢。为了更合理的使用层，可参考 "),r("a",{attrs:{href:"https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count",target:"_blank",rel:"noopener noreferrer"}},[t._v("坚持仅合成器的属性和管理层计数"),r("OutboundLink")],1),t._v(" 。")]),t._v(" "),r("p",[t._v("一旦层树被创建，渲染顺序被确定，主线程会把这些信息通知给合成器线程，合成器线程会栅格化每一层。有的层的可以达到整个页面的大小，因此，合成器线程将它们分成多个磁贴，并将每个磁贴发送到栅格线程，栅格线程会栅格化每一个磁贴并存储在 GPU 显存中。")]),t._v(" "),r("p",[t._v("一旦磁贴被光栅化，合成器线程会收集称为绘制四边形的磁贴信息以创建合成帧。")]),t._v(" "),r("p",[t._v("合成帧随后会通过 IPC 消息传递给浏览器进程，由于浏览器的 UI 改变或者其它拓展的渲染进程也可以添加合成帧，这些合成帧会被传递给 GPU 用以展示在屏幕上，如果滚动发生，合成器线程会创建另一个合成帧发送给 GPU。")]),t._v(" "),r("p",[t._v("合成器的优点在于，其工作无关主线程，合成器线程不需要等待样式计算或者 JS 执行，这就是为什么合成器相关的动画 最流畅，如果某个动画涉及到布局或者绘制的调整，就会涉及到主线程的重新计算，自然会慢很多。")]),t._v(" "),r("h2",{attrs:{id:"渲染过程概览"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#渲染过程概览"}},[t._v("#")]),t._v(" 渲染过程概览")]),t._v(" "),r("p",[r("img",{attrs:{src:a(400),alt:"渲染流程图"}})]),t._v(" "),r("p",[t._v("首先看一下整个过程的概览。在了解详细内容前，我们也大概知道浏览器最终是通过调用 GPU 完成像素到屏幕的绘制。但这个过程中有很多的步骤。注意概览图中浏览器的渲染进程是放在沙箱进程中由 Blink 处理的，这也是其安全策略。")]),t._v(" "),r("h3",{attrs:{id:"静态渲染过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#静态渲染过程"}},[t._v("#")]),t._v(" 静态渲染过程")]),t._v(" "),r("p",[r("img",{attrs:{src:a(401),alt:"静态渲染过程"}})]),t._v(" "),r("p",[t._v("这一页的内容对于广大前端从业者来说应该都比较熟悉。首先是 HTML 通过 HTMLDocumentParser 转换为 DOM 树，CSS 通过 CSSParser 转换为 StyleRule 集。每个 StyleRule 包含 CSSSelector 和 CSSPropertyValue，当然二者间存在对应关系。再加上浏览器提供的每种类型元素的 DefaultStyle，经过一系列的计算（这一步称为 recalc）生成所有元素包含所有 style 属性值的 ComputedStyle，如右上角的图所示。ComputedStyle 也通过开发者工具和 JS API 暴露了出来，相信大家也不陌生。")]),t._v(" "),r("p",[r("img",{attrs:{src:a(402),alt:"layout图"}})]),t._v(" "),r("p",[t._v("接下来一步就是 layout。layout 的功能是根据上一步得到的所有元素的 computedStyle，将所有元素的位置布局计算好。每个元素在这一步会生成一个 LayoutObject，简单来说其包含四个属性：x、y、width 及 height 用于标识其布局位置。layout 最简单的情况就是，所有的块按照 DOM 顺序从上往下排列，也就是我们常说的流。layout 也包含很复杂的情况，比如带有 overflow 属性的元素，浏览器会计算其 border-box 的长宽和实际内容的长宽。如果设置为 scroll 并且内容超出，还要为其预留滚动条的位置。此外， float、flexbox 等布局也会使得 layout 变复杂。。所以为了解决复杂性的问题，layout 阶段浏览器首先会生成一个和 DOM 树节点大致一一对应的 layout 树，然后遍历该树，将经过计算后得出的位置布局数据填入节点。对于这个过程，Chrome 团队认为没有很好地分离输入和输出，因此下一代的 layout 系统会进行重构，使得分层更加清晰。")]),t._v(" "),r("p",[r("img",{attrs:{src:a(403),alt:"paint图"}})]),t._v(" "),r("p",[t._v("然后进入 paint 阶段。需要注意的是这一步并不是真的绘制，只是生成对应的指令。对于每个 LayoutObject，浏览器会生成一个列表，列表中的每一项记录着绘制指令（比如画个红色的矩形）。记住这个待绘制列表项，后面会出现很多次。绘制按照堆栈也就是 z 轴的顺序在多个阶段进行。每个阶段只根据当前元素对应的属性（background->floats->foregrounds->outlines）进行绘制。注意，绘制并不严格是按照上述四种元素属性顺序，此处只作举例说明。")]),t._v(" "),r("p",[r("img",{attrs:{src:a(404),alt:"raster图"}})]),t._v(" "),r("p",[t._v("下面就进入 raster 阶段，中文名为栅格化。栅格化的操作将上一步 paint 阶段每个 LayoutObject 存储的绘制指令列表中的每一项转换为颜色值的位图。位图中的每一项存储着 RGBA 值，对应着一个像素。位图存在于 GPU 内存中，还没有显示到屏幕上。GPU 除了用来存位图信息，还能执行生成位图的命令，也就是说栅格化过程可通过 GPU 进行，Chrome 默认开启 GPU 栅格化。GPU 栅格化的过程如下：浏览器调用 Skia 库，Skia 库对绘制指令建立单独的缓冲区以进行指令的转译处理，这一过程结束后缓冲区内容被释放输出并生成 OpenGL 调用。至此，这些 OpenGL 调用还存在于渲染沙箱进程，需要通过命令缓冲区机制代理传输到 GPU 进程执行。使用 GPU 进程的原因一是需要绕过渲染器沙箱的限制，二是将 OpenGL 程序如果不稳定或有安全漏洞，隔离开使其不至于影响浏览器的稳定性。在未来演进上，栅格化处理将转移至 GPU 进程中进行，以提升性能。同时 Vulkan 也会被支持。（注：Skia 是一个独立的图形处理函数库，其对硬件做了一层抽象，可以执行一系列相对底层 OpenGL 更复杂的指令。OpenGL 是跨语言跨平台的系统级绘图API。Vulkan 是下一代的绘图 API，旨在替代 OpenGL。）")]),t._v(" "),r("p",[t._v("以上过程揭示了静态渲染，也就是从 web content 到内存中的像素的整个流程。但是实际过程中页面是不断更新的，包括滚动、动画、js 等都会改变页面内容。一个完整的渲染过程是很昂贵的，如何高效更新也是讨论的重点。")]),t._v(" "),r("h3",{attrs:{id:"动态更新过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#动态更新过程"}},[t._v("#")]),t._v(" 动态更新过程")]),t._v(" "),r("p",[r("img",{attrs:{src:a(405),alt:"frame图"}})]),t._v(" "),r("p",[t._v("首先明确一个概念，帧。涉及到时间时，每一帧是当前 Web 内容的完整呈现，通常，如果每秒低于 60 帧，滚动和动画就会显得有些卡顿。")]),t._v(" "),r("p",[r("img",{attrs:{src:a(406),alt:"invalldation图"}})]),t._v(" "),r("p",[t._v("第一个优化方向最容易想到，即跟踪改变的部分，复用没有改变的部分。因此针对第一部分提到的 style、layout、paint、raster，浏览器都做了精细化跟踪失效的处理，每一帧都会复用前一帧没有变化的部分，只有被标记了需要变更的部分才会进行重新处理。")]),t._v(" "),r("p",[r("img",{attrs:{src:a(407),alt:"compositing图"}})]),t._v(" "),r("p",[t._v("由于 JS 和渲染都存在于主线程中，因此如果 JS 占据主线程做了耗时的操作，即使渲染很快，页面看起来仍然是比较卡顿的。所以这又引出了下一个优化点，compositing，中文名合成。")]),t._v(" "),r("p",[r("img",{attrs:{src:a(408),alt:"layer图"}})]),t._v(" "),r("p",[t._v("合成包含两个概念，一是将页面分解成多个 layer，二是将这些 layer 在另一个线程中合成。layer 类似 PS 中图层的概念，可以独立于其他 layer 进行变换和栅格化。开发者工具中对其也有直观的展示。合成线程需要能够处理用户可能导致页面发生变化的输入事件比如（变换、剪切、滚动、特效），因为这些操作涉及了复合图层的改变。这样可以和主线程执行 js 互不干扰。但是当合成线程无法处理某个输入事件时，还是会由主线程来处理。layer 的存储依然是通过树形结构实现。合成更新是新出现的生命周期，出现在 layout 之后 paint 之前。每个 layer 都被单独绘制，因此其也有属于自己的绘制指令列表。未来，Chrome 可能会将合成图层生命周期放到 paint 后面。")]),t._v(" "),r("p",[r("img",{attrs:{src:a(409),alt:"layer-tree图"}})]),t._v(" "),r("p",[t._v("主线程的绘制阶段完成后，主线程上的 layer tree 将会被复制到合成线程上，合成完毕后再返回主线程。整个过程类似 git 中分支代码的合并。")]),t._v(" "),r("p",[r("img",{attrs:{src:a(410),alt:"tiling-drawing图"}})]),t._v(" "),r("p",[t._v("合成线程中，在对图层进行栅格化之前，还会有一步 tiling 的操作，也就是将 layer 拆分为多个小图块（tile），目的是为了防止出现某些情况下，某个滚动 layer 很长，但实际只需要展示当前容器内的一小块，如果整个 layer 进行栅格化将会比较浪费资源。复杂管理分块的模块叫 tile manager，它会随着滚动区域的变化，优先创建相邻的图块。所有图块栅格化完成后，合成线程将绘制 quads（四边形绘制）。一个 quad 类似于在屏幕上绘制一个图块的指令，其引用在内存中生成的栅格图块，然后被封装，由渲染进程提交到浏览器进程，这些就是每个动画帧。")]),t._v(" "),r("p",[r("img",{attrs:{src:a(411),alt:"activation图"}})]),t._v(" "),r("p",[t._v("这里为了实现可以一边可以执行前一个提交的图块绘制任务，一边继续等待新的任务，合成线程还做了一些优化，实现了一个 pending layer tree。其接收 commit，当其准备好绘制后，会被激活（activation）从而复制到 active layer tree 上进行绘制任务。")]),t._v(" "),r("p",[r("img",{attrs:{src:a(412),alt:"display图"}})]),t._v(" "),r("p",[t._v("浏览器拿到渲染进程发来的动画帧之后，结合非内容区的其他渲染进程（比如浏览器 UI），调用 OpenGL 指令绘制最终的画面。")]),t._v(" "),r("h3",{attrs:{id:"小结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),r("p",[t._v("渲染过程的每个步骤，web 内容、生成 DOM 树、解决样式问题、更新布局、生成合成图层、把图层绘制到待显示项列表中、把图层树提交给合成线程、把图层切分为小图块、对图块进行栅格化操作、把 pending layer tree 复制到 active layer tree、把树绘制成 quads、提交 quad 到浏览器进程、通过 GPU 进程调用 GL 指令绘制像素至屏幕上。")]),t._v(" "),r("h3",{attrs:{id:"渲染优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#渲染优化"}},[t._v("#")]),t._v(" 渲染优化")]),t._v(" "),r("p",[t._v("1.HTML文档结构层次尽量少，最好不深于六层;")]),t._v(" "),r("p",[t._v("2.脚本尽量后放，放在前即可;")]),t._v(" "),r("p",[t._v("3.少量首屏样式内联放在标签内;")]),t._v(" "),r("p",[t._v("4.样式结构层次尽量简单;")]),t._v(" "),r("p",[t._v("5.在脚本中尽量减少DOM操作，尽量缓存访问DOM的样式信息，避免过度触发回流;")]),t._v(" "),r("p",[t._v("6.减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画;")]),t._v(" "),r("p",[t._v("7.动画尽量使用在绝对定位或固定定位的元素上;")]),t._v(" "),r("p",[t._v("8.隐藏在屏幕外，或在页面滚动时，尽量停止动画;")]),t._v(" "),r("p",[t._v("9.尽量缓存DOM查找，查找器尽量简洁;")]),t._v(" "),r("p",[t._v("10.涉及多域名的网站，可以开启域名预解析")]),t._v(" "),r("Valine")],1)}),[],!1,null,null,null);e.default=v.exports}}]);