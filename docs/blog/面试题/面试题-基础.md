# <center>面试题-基础</center>

## html5新特性、语义化

- 语义化标签 ： header nav main article section aside footer

```js
语义化意味着顾名思义，HTML5的语义化指的是合理正确的使用语义化的标签来创建页面结构，如 
header,footer,nav，从标签上即可以直观的知道这个标签的作用，而不是滥用div。
语义化的优点有:
代码结构清晰，易于阅读，利于开发和维护
方便其他设备解析（如屏幕阅读器）根据语义渲染网页。
有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重
复制代码
```

### 浏览器渲染机制、重绘、重排

网页生成过程：

- `HTML`被HTML解析器解析成`DOM` 树
- `css`则被css解析器解析成`CSSOM `树
- 结合`DOM`树和`CSSOM`树，生成一棵渲染树(`Render Tree`)
- 生成布局（`flow`），即将所有渲染树的所有节点进行平面合成
- 将布局绘制（`paint`）在屏幕上

**重排(也称回流):** 当`DOM`的变化影响了元素的几何信息(`DOM`对象的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。 触发：

1. 添加或者删除可见的DOM元素
2. 元素尺寸改变——边距、填充、边框、宽度和高度

**重绘：** 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。 触发：

- 改变元素的`color、background、box-shadow`等属性

重排优化建议：

1. 分离读写操作
2. 样式集中修改
3. 缓存需要修改的`DOM`元素
4. 尽量只修改`position：absolute`或`fixed`元素，对其他元素影响不大
5. 动画开始`GPU`加速，`translate`使用`3D`变化

`transform` 不重绘，不回流 是因为`transform`属于合成属性，对合成属性进行`transition/animate`动画时，将会创建一个合成层。这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。浏览器会通过重新复合来创建动画帧。

### css盒子模型

所有`HTML`元素可以看作盒子，在CSS中，`"box model"`这一术语是用来设计和布局时使用。 `CSS`盒模型本质上是一个盒子，封装周围的`HTML`元素，它包括：边距，边框，填充，和实际内容。 盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。

### css样式优先级

```
!important>style>id>class
```

### 什么是BFC？BFC的布局规则是什么？如何创建BFC？BFC应用？

`BFC` 是 `Block Formatting Context `的缩写，即块格式化上下文。`BFC`是CSS布局的一个概念，是一个环境，里面的元素不会影响外面的元素。 布局规则：Box是CSS布局的对象和基本单位，页面是由若干个Box组成的。元素的类型和display属性，决定了这个Box的类型。不同类型的Box会参与不同的`Formatting Context`。 创建：浮动元素 `display：inline-block position:absolute` 应用: 1.分属于不同的`BFC`时,可以防止`margin`重叠 2.清除内部浮动 3.自适应多栏布局

## DOM、BOM对象

`BOM（Browser Object Model）`是指浏览器对象模型，可以对浏览器窗口进行访问和操作。使用 BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。 使 `JavaScript` 有能力与浏览器"对话"。 `DOM （Document Object Model）`是指文档对象模型，通过它，可以访问`HTML`文档的所有元素。 `DOM `是 `W3C`（万维网联盟）的标准。`DOM` 定义了访问 `HTML` 和` XML` 文档的标准： "W3C 文档对象模型（DOM）是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。" `W3C DOM` 标准被分为 3 个不同的部分：

- 核心 `DOM` - 针对任何结构化文档的标准模型
- `XML DOM` - 针对 XML 文档的标准模型
- `HTML DOM` - 针对 HTML 文档的标准模型

什么是` XML DOM`？ `XML DOM` 定义了所有 XML 元素的对象和属性，以及访问它们的方法。 什么是 HTML DOM？ HTML DOM 定义了所有 HTML 元素的对象和属性，以及访问它们的方法。

## JS相关

### js数据类型、typeof、instanceof、类型转换

1. `string、number、boolean、null、undefined、object(function、array)、symbol(ES10 BigInt)`
2. `typeof` 主要用来判断数据类型 返回值有`string、boolean、number、function、object、undefined。`
3. `instanceof` 判断该对象是谁的实例。
4. `null`表示空对象 `undefined`表示已在作用域中声明但未赋值的变量

### 闭包(高频)

闭包是指有权访问另一个函数作用域中的变量的函数 ——《JavaScript高级程序设计》

当函数可以记住并访问所在的词法作用域时，就产生了闭包，

即使函数是在当前词法作用域之外执行 ——《你不知道的JavaScript》

- 闭包用途：
  1. 能够访问函数定义时所在的词法作用域(阻止其被回收)
  2. 私有化变量
  3. 模拟块级作用域
  4. 创建模块
- 闭包缺点：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏

### 原型、原型链(高频)

**原型:** 对象中固有的`__proto__`属性，该属性指向对象的`prototype`原型属性。

**原型链:** 当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是`Object.prototype`所以这就是我们新建的对象为什么能够使用`toString()`等方法的原因。

**特点:** `JavaScript`对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。

### this指向、new关键字

`this`对象是是执行上下文中的一个属性，它指向最后一次调用这个方法的对象，在全局函数中，`this`等于`window`，而当函数被作为某个对象调用时，this等于那个对象。 在实际开发中，`this `的指向可以通过四种调用模式来判断。

1. 函数调用，当一个函数不是一个对象的属性时，直接作为函数来调用时，`this`指向全局对象。
2. 方法调用，如果一个函数作为一个对象的方法来调用时，`this`指向这个对象。
3. 构造函数调用，`this`指向这个用`new`新创建的对象。
4. 第四种是 `apply 、 call 和 bind `调用模式，这三个方法都可以显示的指定调用函数的 this 指向。`apply`接收参数的是数组，`call`接受参数列表，`` bind`方法通过传入一个对象，返回一个` this `绑定了传入对象的新函数。这个函数的 `this`指向除了使用`new `时会被改变，其他情况下都不会改变。

**new**

1. 首先创建了一个新的空对象
2. 设置原型，将对象的原型设置为函数的`prototype`对象。
3. 让函数的`this`指向这个对象，执行构造函数的代码（为这个新对象添加属性）
4. 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。

### 作用域、作用域链、变量提升

`作用域`负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。(全局作用域、函数作用域、块级作用域)。 作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是`作用域链`。

### 继承(含es6)、多种继承方式

（1）第一种是以`原型链的方式来实现继承`，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。

（2）第二种方式是使用`借用构造函数`的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。

（3）第三种方式是`组合继承`，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。

（4）第四种方式是`原型式继承`，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。

（5）第五种方式是`寄生式继承`，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。

（6）第六种方式是`寄生式组合继承`，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。

### EventLoop

```
JS`是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列。微任务队列的代表就是，`Promise.then`，`MutationObserver`，宏任务的话就是`setImmediate setTimeout setInterval
```

### 原生ajax

**ajax**是一种异步通信的方法,从服务端获取数据,达到局部刷新页面的效果。 过程：

1. 创建`XMLHttpRequest`对象;
2. 调用`open`方法传入三个参数 请求方式`(GET/POST)、url、同步异步(true/false)`;
3. 监听`onreadystatechange`事件，当`readystate`等于4时返回`responseText`;
4. 调用send方法传递参数。

### 事件冒泡、捕获(委托)

- **事件冒泡**指在在一个对象上触发某类事件，如果此对象绑定了事件，就会触发事件，如果没有，就会向这个对象的父级对象传播，最终父级对象触发了事件。
- **事件委托**本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为**事件代理**。

`event.stopPropagation()` 或者 ie下的方法 `event.cancelBubble = true;` //阻止事件冒泡

## ES6

1. 新增symbol类型 表示独一无二的值，用来定义独一无二的对象属性名;
2. const/let  都是用来声明变量,不可重复声明，具有块级作用域。存在暂时性死区，也就是不存在变量提升。(const一般用于声明常量);
3. 变量的解构赋值(包含数组、对象、字符串、数字及布尔值,函数参数),剩余运算符(...rest);
4. 模板字符串(`${data}`);
5. 扩展运算符(数组、对象);;
6. 箭头函数;
7. Set和Map数据结构;
8. Proxy/Reflect;
9. Promise;
10. async函数;
11. Class;
12. Module语法(import/export)。

### ES6里的symble

它的功能类似于一种标识唯一性的ID，每个`Symbol`实例都是唯一的。 `Symbol`类型的key是不能通过`Object.keys()`或者`for...in`来枚举的， 它未被包含在对象自身的属性名集合(`property names`)之中。 所以，利用该特性，我们可以把一些不需要对外操作和访问的属性使用Symbol来定义。 // 使用`Object的API` `Object.getOwnPropertySymbols(obj)` // [Symbol(name)]

// 使用新增的反射API `Reflect.ownKeys(obj) `// [Symbol(name), 'age', 'title']

### ES6里的set和map

- `Map`对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。构造函数Map可以接受一个数组作为参数。
- `Set`对象允许你存储任何类型的值，无论是原始值或者是对象引用。它类似于数组，但是成员的值都是唯一的，没有重复的值。

### vue的key

1. `key`的作用主要是为了高效的更新虚拟`DOM`,其原理是`vue`在`patch`过程中通过`key`可以精准判断两个节点是否是同一个，

从而避免频繁更新不同元素，使得整个`patch`过程更加高效，减少`DOM`操作量,提高性能。 2. 另外,若不设置`key`还可能在列表更新时引发一些隐蔽的bug 3. `vue`中在使用相同标签名元素的过渡切换时,也会使用到key属性,其目的也是为了让vue可以区分它们， 否则`vue`只会替换其内部属性而不会触发过渡效果。

### 普通函数和箭头函数的区别

1. 箭头函数是匿名函数，不能作为构造函数，不能使用new
2. 箭头函数不绑定`arguments`，取而代之用`rest`参数...解决
3. 箭头函数不绑定`this`，会捕获其所在的上下文的this值，作为自己的this值
4. 箭头函数通过 `call()  或   apply()` 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。
5. 箭头函数没有原型属性
6. 箭头函数不能当做`Generator`函数,不能使用`yield`关键字

**总结：**

- 箭头函数的 `this `永远指向其上下文的 ` this` ，任何方法都改变不了其指向，如`call() ,  bind() ,  apply()`
- 普通函数的this指向调用它的那个对象

## JS函数柯里化

1. 参数复用
2. 提前确认
3. 延迟运行

```javascript
// 普通的add函数
function add(x, y) {
    return x + y
}

// Currying后
function curryingAdd(x) {
    return function (y) {
        return x + y
    }
}

add(1, 2)           // 3
curryingAdd(1)(2)   // 3
```

