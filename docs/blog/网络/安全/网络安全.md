# <center>网络安全</center>

## XSS攻击

**XSS** 又称为 CSS，全程为 Cross-site script，跨站脚本攻击，为了和 CSS 层叠样式表区分所以取名为 XSS，是 Web 程序中常见的漏洞。

其原理是攻击者向有 XSS 漏洞的网站中输入恶意的 HTML 代码，当其它用户浏览该网站时候，该段 HTML 代码会自动执行，从而达到攻击的目的，如盗取用户的 Cookie，破坏页面结构，重定向到其它网站等。

### XSS 类型：
根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。


| 类型	| 存储区 | 插入点 |
| ---- | ---- | -----|
|存储型 XSS| 后端数据库 | HTML |
|反射型 XSS| URL|	HTML |
|DOM 型 XSS| 后端数据库/前端存储/URL	| 前端 JavaScript |

- 存储区：恶意代码存放的位置。
- 插入点：由谁取得恶意代码，并插入到网页上。

#### 存储型 XSS
存储型 XSS 的攻击步骤：

- 攻击者将恶意代码提交到目标网站的数据库中。
- 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
- 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
- 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。



#### 反射型 XSS
反射型 XSS 的攻击步骤：

- 攻击者构造出特殊的 URL，其中包含恶意代码。
- 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
- 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
- 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。


反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。

反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。

由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。

POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。

#### DOM 型 XSS
DOM 型 XSS 的攻击步骤：

- 攻击者构造出特殊的 URL，其中包含恶意代码。
- 用户打开带有恶意代码的 URL。
- 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
- 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。


DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。

<hr>
XSS 攻击总结起来有两大要素:

- 攻击者提交恶意代码。
- 浏览器执行恶意代码。

#### XSS Payload攻击

> XSS攻击成功后，攻击者能够对用户当前浏览的页面植入恶意脚本，通过恶意脚本，控制用户的浏览器。这些用以完成各种具体功能的恶意脚本，被称为XSS Payload。实际上就是Javascript脚本（或者Flash或其他富客户端的脚本），所以XSS Payload能够做到任何javascript脚本能实现的功能



### XSS 攻击的预防

#### 预防存储型和反射型 XSS 攻击

存储型和反射型 XSS 都是在服务端取出恶意代码后，插入到响应 HTML 里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。

预防这两种漏洞，有两种常见做法：

- 改成纯前端渲染，把代码和数据分隔开。
- 对 HTML 做充分转义。

**纯前端渲染** 
 
- 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。
- 然后浏览器执行 HTML 中的 JavaScript。
- JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。

在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。

但纯前端渲染还需注意避免 DOM 型 XSS 漏洞（例如 onload 事件和 href 中的 javascript:xxx等，请参考下文”预防 DOM 型 XSS 攻击“部分）。

在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。


**转义 HTML** 
 
如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义。

常用的模板引擎，如 doT.js、ejs、FreeMarker 等，对于 HTML 转义通常只有一个规则，就是把 & < > " ' / 这几个字符转义掉，确实能起到一定的 XSS 防护作用，但并不完善：


| XSS 安全漏洞	| 简单转义是否有防护作用| 
| ---------- | ------------------ | 
| HTML | 标签文字内容 | 	有| 
| HTML|  属性值 | 	有| 
| CSS | 内联样式 | 	无| 
| 内联|  JavaScript | 	无| 
| 内联 | JSON	| 无| 
| 跳转链接	| 无| 


#### 预防 DOM 型 XSS 攻击

DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。

在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。

如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。

DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等， a标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。

### 其他 XSS 防范措施

虽然在渲染页面和执行 JavaScript 时，通过谨慎的转义可以防止 XSS 的发生，但完全依靠开发的谨慎仍然是不够的。以下介绍一些通用的方案，可以降低 XSS 带来的风险和后果。

#### 内容安全策略 CSP (Content Security Policy) 

> 内容安全策略 (CSP) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。

严格的 CSP 在 XSS 的防范中可以起到以下的作用：

- 禁止加载外域代码，防止复杂的攻击逻辑。
- 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。
- 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。
- 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。
- 合理使用上报可以及时发现 XSS，利于尽快修复问题。


#### 输入内容长度控制

对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。

#### 其他安全措施

- HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。
- 验证码：防止脚本冒充用户提交危险操作。


## CSRF 攻击

> CSRF全称为跨站请求伪造（Cross-site request forgery），是一种网络攻击方式，也被称为 one-click attack 或者 session riding。

### CSRF 攻击原理

CSRF 攻击利用网站对于用户网页浏览器的信任，挟持用户当前已登陆的Web应用程序，去执行并非用户本意的操作。

### 预防CSRF 攻击

- 只使用JSON API


	使用JavaScript发起AJAX请求是限制跨域的，并不能通过简单的 <form> 表单来发送JSON，所以，通过只接收JSON可以很大可能避免CSRF攻击。


- 验证HTTP Referer字段


	根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如上文中用户User想要在网站WebA中进行转账操作，那么用户User

	 - 必须先登录WabA
	 - 然后再通过点击页面上的按钮出发转账事件

	这时该转帐请求的 Referer 值就会是转账按钮所在的页面的URL，而如果黑客要对银行网站实施 CSRF攻击，他只能在他自己的网站构造请求，当用户User通过黑客的网站发送请求到WebA时，该请求的 Referer 是指向黑客自己的网站。
因此，要防御 CSRF 攻击，网站WebA只需要对于每一个转账请求验证其 Referer 值，如果是以网站WebA的网址开头的域名，则说明该请求是来自WebA自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。


- 在请求地址中添加takon验证


	CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。  
	
	这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对。


## Cookie使用注意点
- http-only：不能通过JavaScript访问到Cookie，防止XSS攻击。
- same-site：不能在跨域请求中携带Cookie，防止CSRF攻击。

## ISN 攻击
序列号对TCP通信来讲就相当于双方对话的暗号，这边说“天王盖地虎”，那边就要说“宝塔镇河妖”，对上号了数据就进入后续环节进行处理。所以TCP ISN最重要的特性就是随机性或不可预测性，如果ISN可以预测，那就会带来各种安全问题。

本节假设TCP的ISN可以被预测，并且传输没有加密，双方仅使用IP地址进行验证，讨论几个ISN相关的攻击。但是并不是说加密就可以避免ISN的相关攻击，只是对于的攻击类型不同，要更复杂。

假设C和S正在进行TCP通信，X是破坏者，可以预测TCP ISN。X可能的攻击包括：

### 一、身份仿冒
攻击过程简述如下：

- X首先对C进行攻击（比如Syn Flood），导致C不可用。
- 然后X仿冒C的地址对S发起连接请求。
- S对C进行回应，附带ISN。注意：这个报文X是收不到的。
- X可以预测ISN，可以按预测的ISN直接给S回应确认，这时S误认为已经和C建立了连接。
- X这时就可以仿冒C的地址，发送恶意指令给S，S会认为这是C下发的指令，被欺骗执行，攻击生效。

这个攻击过程中，X不需要获得S的任何报文，就可以对S下发数据，这些数据可能是恶意指令，从而达到攻击的目的。

### 二、DoS攻击
因为X可以预测C和S的序列号，就可以在C和S通信的过程中，假冒一方的IP地址，频繁抢先一步发送错误的报文：

- 发送序列号正确的ack报文，导致很多正确的报文被丢弃，TCP连接看上起正常，但是因为很多正确的报文被丢弃，实际处于拒绝服务状态。
- 发送序列号正确的fin报文，导致TCP连接关闭，系统处于拒绝服务状态。

### 三、信息投毒

和DoS攻击类似，但属于更高级别的攻击。因为X可以预测ISN，就可以在通信过程中，假冒其中一方，使用正确的序列号抢先发送非法内容，而正确的报文在到达时被认为是重复的无效报文被丢弃。

这种攻击需要对双方通信协议的内容有一定的了解，塞入的报文符合原来通信规格要求，被认为是合法报文进行了处理。


## SYN攻击
- 什么是 **SYN** 攻击(SYN Flood)?
	在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态.

	**SYN** 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。

	**SYN** 攻击是一种典型的 **DoS/DDoS** 攻击.

- 如何检测 SYN 攻击？

	检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。
	
- 如何防御 SYN 攻击？

	SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：

	- 缩短超时（SYN Timeout）时间
	- 增加最大半连接数
	- 过滤网关防护
	- SYN cookies技术
	
	
	
	
	
	
	

	<Valine></Valine>