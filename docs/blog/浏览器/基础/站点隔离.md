# <center>浏览器-站点隔离<center>

## 介绍
**站点隔离(Site isolation)** 是 Chrome 为应对潜在的安全问题所实现的功能，以防止恶意网站获取其他网站的信息。  

通常，Chrome会把一个标签默认为一个进程，但当网页之间存在共享内容时，彼此可以共享同一个进程。而网站隔离可消除共享进程，确保不同网站在不同的进程上，以此防止发生类似幽灵（Spectre）和熔毁（Meltdown）的攻击。而现在这一功能在Chrome 浏览器中是默认启用的。这就意味着系统将会对诸多令人讨厌的漏洞进行自动防御，但这也意味着Chrome——在其运行时已然占用了计算机的部分资源——现在要多使用10-13%的内存。

有人可能要问，浏览器的同源策略不就是干这个的吗？是的，同源策略确实可以起到保护作用。

Site isolation 提供了第二层的额外保护，将同源策略与进程的地址空间隔离结合起来，把不同的网站隔离在不同的进程中，并且阻止一个进程获得其他网站的敏感信息。这样即使存在 spectre 类型的旁路攻击，可以获取进程内任意内存地址的数据，也不能获得其他网站的信息。

Site Isolation主要由两部分组成。进程模型的修改和跨域读取屏蔽 (CORB)。

### 进程模型
目前 Chrome 默认的进程模型叫做 process-per-site-instance (还有其他的进程模型如 process-per-site 和 process-per-tab)[3]。这个进程模型基本上就是为每个页面创建一个进程，但是还是存在不同的网站用同一个进程的情况，如 iframes 和父页面，同一个标签页里的页面跳转，以及标签页过多的时候等。Site isolation 引入了一个新的策略叫做 site-per-process。这个策略更为严格，只要是不同的网站，不管你是在新的标签页打开，还是在同一个标签页跳转，还是嵌在 iframes 里，统统都要换一个新的进程。这里主要的工作量是把 iframes 给拿出来放到不同的进程里(所谓的 OOPIF, out of process iframe)。

Firefox 目前也是多进程的模型，但最多只用四个进程来渲染页面内容，目前 Firefox 也有一个文档在考虑进程隔离的问题

**不同的网站 (site) 的定义**

使用同一个协议，同一个注册域名 (所谓的 eTLD+1) 的网址都属于同一个网站，这比同源策略里的 same origin 要宽泛一些，不同的子域名，不同的端口都算同一个网站。

### CORB

CORB (Cross-Origin Read Blocking) 是一个屏蔽跨域资源加载的功能。

同源策略可以防止恶意网站获取其他网站的信息，但有一些例外如 `<img>`和`<script>`。类似:

`<img src="https://example.com/secret.json">`

的跨站请求可以发起，只是返回的结果被过滤掉了，在解析图片时出错[5]。这时候跨域的资源其实已经传入到了这个进程里面，结合 spectre 类型的旁路攻击或者其他漏洞是可以拿到这些信息的。 CORB 的想法就是直接屏蔽掉跨域资源返回的结果，让地址空间里都没有返回的结果。目前只有HTML，XML 和 JSON 类型的资源会被 CORB 保护。

## 什么是Spectre和Meltdown攻击？

Spectre和Meltdown是同一漏洞的两个不同的变种。

从技术上来说变异有三种。其中两个合并成了Spectre，而另一个是Meltdown。为了访问部分内存，这些攻击会利用所谓的前瞻执行，然后使用时序攻击法来发现存储在那里的数值。

**前瞻执行** 是一种能够帮助芯片运行更快速的机制。用一个例子来说明这一点是最容易的。假设一个程序将要提供一个是或否的选择，而每个答案会导致进入一个不同的进程。与其等待用户进行决策，芯片会开始同时计算这两个功能，因此这便会有一个好的开端，而不管用户会选择什么。

在前瞻执行期间所使用到的数据通常会被保存在CPU缓存中，这就像一个小的内存壁龛，可以帮助加速从RAM中获取数据。

现在，让我们来把所有这些联系在一起。Spectre和Meltdown是利用芯片的前瞻执行功能来达到攻击目的的两种攻击，它们会使用时序攻击法来暴露在这一过程中所加载的数据，然后再把它们转储到CPU缓存中。














