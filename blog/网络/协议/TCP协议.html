<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>逆夏的博客</title>
    <meta name="generator" content="VuePress 1.5.0">
    
    <meta name="description" content="凉风把枫叶吹红，冷言让强者成熟">
    <link rel="preload" href="/blog/assets/css/0.styles.56a09861.css" as="style"><link rel="preload" href="/blog/assets/js/app.f0ef88ef.js" as="script"><link rel="preload" href="/blog/assets/js/2.8018e2e2.js" as="script"><link rel="preload" href="/blog/assets/js/6.595db461.js" as="script"><link rel="preload" href="/blog/assets/js/18.4b507252.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.7fcf6999.js"><link rel="prefetch" href="/blog/assets/js/11.c0725cdb.js"><link rel="prefetch" href="/blog/assets/js/12.53f66bb2.js"><link rel="prefetch" href="/blog/assets/js/13.430875aa.js"><link rel="prefetch" href="/blog/assets/js/14.3dab09ed.js"><link rel="prefetch" href="/blog/assets/js/15.58f29d65.js"><link rel="prefetch" href="/blog/assets/js/16.61800840.js"><link rel="prefetch" href="/blog/assets/js/17.185af50f.js"><link rel="prefetch" href="/blog/assets/js/19.ec88fb23.js"><link rel="prefetch" href="/blog/assets/js/20.3a339629.js"><link rel="prefetch" href="/blog/assets/js/21.8c742bc9.js"><link rel="prefetch" href="/blog/assets/js/22.7e5987e3.js"><link rel="prefetch" href="/blog/assets/js/23.434abd07.js"><link rel="prefetch" href="/blog/assets/js/24.9dc03081.js"><link rel="prefetch" href="/blog/assets/js/25.1da05b1e.js"><link rel="prefetch" href="/blog/assets/js/26.7a4fd4c5.js"><link rel="prefetch" href="/blog/assets/js/27.7af73fd7.js"><link rel="prefetch" href="/blog/assets/js/28.a265a463.js"><link rel="prefetch" href="/blog/assets/js/29.9cc2048c.js"><link rel="prefetch" href="/blog/assets/js/3.ea5004f2.js"><link rel="prefetch" href="/blog/assets/js/30.3cc1440d.js"><link rel="prefetch" href="/blog/assets/js/31.fa029781.js"><link rel="prefetch" href="/blog/assets/js/32.c54b40e0.js"><link rel="prefetch" href="/blog/assets/js/33.9e14a36e.js"><link rel="prefetch" href="/blog/assets/js/34.0f8bd32e.js"><link rel="prefetch" href="/blog/assets/js/35.7714042a.js"><link rel="prefetch" href="/blog/assets/js/36.345b1d96.js"><link rel="prefetch" href="/blog/assets/js/37.958f4e57.js"><link rel="prefetch" href="/blog/assets/js/38.bb0d0bb9.js"><link rel="prefetch" href="/blog/assets/js/39.9a814394.js"><link rel="prefetch" href="/blog/assets/js/4.7e8269c2.js"><link rel="prefetch" href="/blog/assets/js/40.ddb3beb4.js"><link rel="prefetch" href="/blog/assets/js/41.f519f588.js"><link rel="prefetch" href="/blog/assets/js/42.3baa21d2.js"><link rel="prefetch" href="/blog/assets/js/43.e50fa78a.js"><link rel="prefetch" href="/blog/assets/js/44.9a2db179.js"><link rel="prefetch" href="/blog/assets/js/45.36cb132b.js"><link rel="prefetch" href="/blog/assets/js/46.33a459b0.js"><link rel="prefetch" href="/blog/assets/js/47.fdaf0f4e.js"><link rel="prefetch" href="/blog/assets/js/48.898bdb9d.js"><link rel="prefetch" href="/blog/assets/js/49.e4698de4.js"><link rel="prefetch" href="/blog/assets/js/5.ebbe82f6.js"><link rel="prefetch" href="/blog/assets/js/50.6dfaf14b.js"><link rel="prefetch" href="/blog/assets/js/51.516ec6f5.js"><link rel="prefetch" href="/blog/assets/js/52.b20e278c.js"><link rel="prefetch" href="/blog/assets/js/53.364b4c1c.js"><link rel="prefetch" href="/blog/assets/js/54.0ecbd5de.js"><link rel="prefetch" href="/blog/assets/js/7.a8f2d87d.js"><link rel="prefetch" href="/blog/assets/js/8.b22711c9.js"><link rel="prefetch" href="/blog/assets/js/9.d3060a61.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.56a09861.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">逆夏的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/blog/引言/引言.html" class="nav-link">
  博客
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/yuanzhengqiang" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub地址
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/blog/引言/引言.html" class="nav-link">
  博客
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/yuanzhengqiang" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub地址
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>引言</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>框架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>浏览器</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>网络</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>请求</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>协议</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-2"><p class="sidebar-heading open"><span>TCP</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/blog/网络/协议/TCP协议.html" class="active sidebar-link">TCP协议</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/blog/网络/协议/TCP协议.html#三次握手-建立链接" class="sidebar-link">三次握手-建立链接</a></li><li class="sidebar-sub-header"><a href="/blog/blog/网络/协议/TCP协议.html#四次挥手-关闭链接" class="sidebar-link">四次挥手-关闭链接</a></li><li class="sidebar-sub-header"><a href="/blog/blog/网络/协议/TCP协议.html#tcp-慢开始-14kb-规则" class="sidebar-link">TCP 慢开始 / 14kb 规则</a></li><li class="sidebar-sub-header"><a href="/blog/blog/网络/协议/TCP协议.html#tcp-keepalive" class="sidebar-link">TCP KeepAlive</a></li></ul></li></ul></section></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>安全</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>常见面试题</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>缓存</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>构建</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>设计模式</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="tcp协议"><a href="#tcp协议" class="header-anchor">#</a> <center>TCP协议</center></h1> <h3 id="tcp-的特性"><a href="#tcp-的特性" class="header-anchor">#</a> TCP 的特性</h3> <ul><li>TCP 提供一种<strong>面向连接</strong>的、<strong>可靠</strong>的字节流服务</li> <li>在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP</li> <li>TCP 使用校验和，确认和重传机制来保证可靠传输</li> <li>TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复</li> <li>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li></ul> <p><strong>注意</strong>：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。</p> <h2 id="三次握手-建立链接"><a href="#三次握手-建立链接" class="header-anchor">#</a> 三次握手-建立链接</h2> <p>所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。</p> <p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。</p> <ul><li><p>第一次握手(SYN=1, seq=x):</p> <p>客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。</p> <p>发送完毕后，客户端进入 SYN_SEND 状态。</p></li> <li><p>第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):</p> <p>服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端初始化自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。</p></li> <li><p>第三次握手(ACK=1，ACKnum=y+1)</p> <p>客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1</p> <p>发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。</p></li></ul> <p>三次握手的过程的示意图如下：</p> <p><img src="/blog/assets/img/tcp-connection-made-three-way-handshake.dc84424c.png" alt="sss"></p> <h3 id="为什么是三次握手"><a href="#为什么是三次握手" class="header-anchor">#</a> 为什么是三次握手</h3> <ul><li>tcp连接是全双工的，数据在两个方向上能同时传递。</li> <li>所以要确保双方，同时能发数据和收数据</li> <li>第一次握手：证明了发送方能发数据</li> <li>第二次握手：ack确保了接收方能收数据，syn确保了接收方能发数据</li> <li>第三次握手：确保了发送方能收数据</li> <li>实际上是四个维度的信息交换，不过中间两步合并为一次握手了。</li> <li>四次握手浪费，两次握手不能保证“双方同时具备收发功能”</li></ul> <p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p> <h3 id="序列号"><a href="#序列号" class="header-anchor">#</a> 序列号</h3> <p>在上文中提到的初始化 <strong>序列号</strong> (英文为：Initial Sequence Number，简称<strong>ISN</strong>);</p> <p>TCP初始化序列号不能设置为一个固定值，因为这样容易被攻击者猜出后续序列号，从而遭到攻击。</p> <p>RFC1948中提出了一个较好的初始化序列号ISN随机生成算法。</p> <p><strong><center>ISN = M + F(localhost, localport, remotehost, remoteport)</center></strong></p> <ul><li><p><strong>M</strong>是一个计时器，这个计时器每隔4毫秒加1。</p></li> <li><p><strong>F</strong>是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出，用<strong>MD5</strong>算法是一个比较好的选择。</p></li></ul> <h4 id="初始化序列号的目的"><a href="#初始化序列号的目的" class="header-anchor">#</a> 初始化序列号的目的</h4> <p>由于A和B之间的一个tcp连接通常是由A和B的2个ip地址，2个端口号构成的四元组，因此当A出现了故障把这个tcp连接断开了，之后再以相同的四元组建立新的tcp连接（也就是说A和B两次建立tcp连接都是使用了相同的ip地址和端口），就会出现数据乱序的问题。</p> <p>换句话说，只要A发送了一个tcp报文段，且这个tcp报文段的四元组和序号，和之前的tcp连接（四元组和序号）相同的话，就会被B确认。这其实反映了tcp的一些缺点，如果被一些恶意攻击者加以利用tcp的这种缺点：选择合适的序号，ip地址和端口的话，就能伪造出一个tcp报文段，从而打断正常的tcp连接。但是初始化序号的方式（通过算法来随机生成序号）就会使序号难以猜出，也就不容易利用这种缺点来进行一些恶意攻击行为。</p> <p>通过上面所述我们知道，如果A和B之间发送数据每次都使用相同序号的话可能会引发一系列的问题，但是使用不同序号的话，那么B在接收到这个序号为1的tcp报文时，发现这个tcp报文的序号不在新tcp连接的接收范围内时会把这个tcp报文丢弃掉，也就避免了数据乱序的问题。</p> <p>因此我们可以明白，客户端和服务端双方在建立tcp连接并初始化序列号，那么上面所说的这些情况从一开始就可以避免。另外，tcp在初始化序列号的过程也是比较复杂的，一般来说，这个序号的范围是0 ~ 2^31之间，而且序号的生成也是随机的，通常是一个很大的数值，也就是说每个tcp连接使用的序号也是不一样的。</p> <h3 id="tcp-缓冲区的数据结构"><a href="#tcp-缓冲区的数据结构" class="header-anchor">#</a> TCP 缓冲区的数据结构</h3> <p><img src="/blog/assets/img/tcp-buffer.bce3ff4e.jpg" alt="数据结构图"></p> <ul><li><p>接收端：</p> <ul><li>LastByteRead: 缓冲区读取到的位置</li> <li>NextByteExpected：收到的连续包的最后一个位置</li> <li>LastByteRcvd：收到的包的最后一个位置</li> <li>中间空白区：数据没有到达</li></ul></li> <li><p>发送端：</p> <ul><li>LastByteAcked: 被接收端ack的位置，表示成功发送确认</li> <li>LastByteSent：发出去了，还没有收到成功确认的Ack</li> <li>LastByteWritten：上层应用正在写的地方</li></ul></li></ul> <h3 id="滑动窗口示意图"><a href="#滑动窗口示意图" class="header-anchor">#</a> 滑动窗口示意图</h3> <h4 id="滑动初始示意图"><a href="#滑动初始示意图" class="header-anchor">#</a> 滑动初始示意图</h4> <p><img src="/blog/assets/img/tcp-sliding-window.03bb82da.jpg" alt="初始示意图"></p> <ul><li>黑框表示滑动窗口</li> <li>'#1'表示收到ack确认的数据</li> <li>'#2'表示还没收到ack的数据</li> <li>'#3'表示在窗口中还没有发出的（接收方还有空间）</li> <li>'#4'窗口以外的数据（接收方没空间）</li></ul> <h4 id="滑动过程示意图"><a href="#滑动过程示意图" class="header-anchor">#</a> 滑动过程示意图</h4> <p><img src="/blog/assets/img/tcp-sliding-processes.d3037487.jpg" alt="滑动过程"></p> <ul><li>收到36的ack，并发出46-51的字节</li></ul> <h4 id="拥塞窗口"><a href="#拥塞窗口" class="header-anchor">#</a> 拥塞窗口</h4> <ul><li>解决什么问题：发送方发送速度过快，导致中转路由器拥堵的问题</li> <li>机制：发送方增加一个拥塞窗口（cwnd），每次受到ack，窗口值加1。发送时，取拥塞窗口和接收方发来的窗口大小取最小值发送</li> <li>起到发送方流量控制的作用</li></ul> <h4 id="滑动窗口会引发的问题"><a href="#滑动窗口会引发的问题" class="header-anchor">#</a> 滑动窗口会引发的问题</h4> <h5 id="零窗口"><a href="#零窗口" class="header-anchor">#</a> 零窗口</h5> <ul><li>如何发生： 接收端处理速度慢，发送端发送速度快。窗口大小慢慢被调为0</li> <li>如何解决：ZWP技术。发送zwp包给接收方，让接收方ack他的窗口大小。</li></ul> <h4 id="糊涂窗口综合征"><a href="#糊涂窗口综合征" class="header-anchor">#</a> 糊涂窗口综合征</h4> <ul><li>如何发生：接收方太忙，取不完数据，导致发送方越来越小。最后只让发送方传几字节的数据。</li> <li>缺点：数据比tcp和ip头小太多，网络利用率太低。</li> <li>如何解决：避免对小的窗口大小做响应。
<ul><li>发送端：前面说到的Nagle算法。</li> <li>接收端：窗口大小小于某个值，直接ack（0），阻止发送数据。窗口变大后再发。</li></ul></li></ul> <h4 id="拥塞处理"><a href="#拥塞处理" class="header-anchor">#</a> 拥塞处理</h4> <ul><li>拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。</li> <li>拥塞处理包括了四个算法，分别为：<strong>慢开始</strong>，<strong>拥塞避免</strong>，<strong>快速重传</strong>，<strong>快速恢复</strong></li></ul> <h5 id="慢开始算法"><a href="#慢开始算法" class="header-anchor">#</a> 慢开始算法</h5> <blockquote><p>慢开始算法，顾名思义，就是在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。想必大家都下载过资源，每当我们开始下载的时候都会发现下载速度是慢慢提升的，而不是一蹴而就直接拉满带宽</p></blockquote> <ul><li><p>慢开始算法步骤具体如下:</p></li> <li><p>连接初始设置拥塞窗口（Congestion Window） 为 <code>1 MSS</code>（一个分段的最大数据量）</p></li> <li><p>每过一个 <code>RTT</code> 就将窗口大小乘二</p></li> <li><p>指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法。</p></li></ul> <h5 id="拥塞避免算法"><a href="#拥塞避免算法" class="header-anchor">#</a> 拥塞避免算法</h5> <ul><li>拥塞避免算法相比简单点，每过一个 <code>RTT</code> 窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。</li> <li>在传输过程中可能定时器超时的情况，这时候 <code>TCP</code> 会认为网络拥塞了，会马上进行以下步骤：</li></ul> <ol><li>将阈值设为当前拥塞窗口的一半</li> <li>将拥塞窗口设为 <code>1 MSS</code></li> <li>启动拥塞避免算法</li></ol> <h5 id="快速重传"><a href="#快速重传" class="header-anchor">#</a> 快速重传</h5> <blockquote><p>快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号。如果发送端收到三个重复的 ACK，无需等待定时器超时而是直接启动快速重传算法。具体算法分为两种：</p></blockquote> <ul><li><p>TCP Taho 实现如下</p></li> <li><p>将阈值设为当前拥塞窗口的一半</p></li> <li><p>将拥塞窗口设为 <code>1 MSS</code></p></li> <li><p>重新开始慢开始算法</p></li> <li><p><code>TCP Reno</code> 实现如下</p></li></ul> <h5 id="拥塞窗口减半"><a href="#拥塞窗口减半" class="header-anchor">#</a> 拥塞窗口减半</h5> <ul><li>将阈值设为当前拥塞窗口</li> <li>进入快恢复阶段（重发对端需要的包，一旦收到一个新的 ACK 答复就退出该阶段），这种方式在丢失多个包的情况下就不那么好了</li> <li>使用拥塞避免算法</li></ul> <h5 id="tcp-new-ren-改进后的快恢复"><a href="#tcp-new-ren-改进后的快恢复" class="header-anchor">#</a> TCP New Ren 改进后的快恢复</h5> <ul><li>TCP New Reno 算法改进了之前 TCP Reno 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。</li> <li>``在 TCP New Reno 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。</li></ul> <h3 id="超时重传机制"><a href="#超时重传机制" class="header-anchor">#</a> 超时重传机制</h3> <h4 id="背景"><a href="#背景" class="header-anchor">#</a> 背景</h4> <ul><li>接收端给发送端的Ack确认只会确认最后一个连续的包</li> <li>比如发送1,2,3,4,5共五份数据，接收端收到1,2，于是回ack3，然后收到4（还没收到3），此时tcp不会跳过3直接确认4，否则发送端以为3也收到了。这时你能想到的方法是什么呢？tcp又是怎么处理的呢？</li></ul> <h4 id="被动等待的超时重传策略"><a href="#被动等待的超时重传策略" class="header-anchor">#</a> 被动等待的超时重传策略</h4> <ul><li>直观的方法是：接收方不做任何处理，等待发送方超时，然后重传。
<ul><li>缺点：发送端不知道该重发3，还是重发3,4,5</li></ul></li> <li>如果发送方如果只发送3：节省宽度，但是慢</li> <li>如果发送方如果发送3,4,5：快，但是浪费宽带</li> <li>总之，都在被动等待超时，超时可能很长。所以tcp不采用此方法</li></ul> <h4 id="主动的快速重传机制"><a href="#主动的快速重传机制" class="header-anchor">#</a> 主动的快速重传机制</h4> <p>英文名为：Fast Retransmit, 不以实际驱动，而以数据驱动重传</p> <h5 id="实现原理"><a href="#实现原理" class="header-anchor">#</a> 实现原理</h5> <ul><li>如果包没有送达，就一直ack最后那个可能被丢的包</li> <li>发送方连续收到3相同的ack，就重传。不用等待超时</li></ul> <p><img src="/blog/assets/img/tcp-retransmission.5fb7259a.jpg" alt="tcp-重传"></p> <ul><li>图中发生1,2,3,4,5数据</li> <li>数据1到达，发生ack2</li> <li>数据2因为某些原因没有送到</li> <li>后续收到3的时候，接收端并不是ack4，也不是等待。而是主动ack2</li> <li>收到4,5同理，一直主动ack2</li> <li>客户端收到三次ack2，就重传2</li> <li>2收到后，结合之前收到的3,4,5，直接ack6</li></ul> <h5 id="快速重传的利弊"><a href="#快速重传的利弊" class="header-anchor">#</a> 快速重传的利弊</h5> <ul><li>解决了被动等待timeout的问题</li> <li>无法解决重传之前的一个，还是所有的问题。</li> <li>上面的例子中是重传2，还是重传2,3,4,5。因为并不清楚ack2是谁传回来的</li></ul> <h4 id="sack方法"><a href="#sack方法" class="header-anchor">#</a> SACK方法</h4> <ul><li>为了解决快速重传的缺点，一种更好的SACK重传策略被提出</li> <li>基于快速重传，同时在tcp头里加了一个SACK的东西</li> <li>解决了什么问题：客户端应该发送哪些超时包的问题</li></ul> <h5 id="实现原理-2"><a href="#实现原理-2" class="header-anchor">#</a> 实现原理</h5> <ul><li>SACK记录一个数值范围，表示哪些数据收到了</li> <li>linux2.4后默认打开该功能，之前版本需要配置tcp-sack参数</li> <li>SACK只是一种辅助的方式，发送方不能完全依赖SACK。主要还是依赖ACK和timout</li></ul> <h5 id="duplicate-sack-d-sack"><a href="#duplicate-sack-d-sack" class="header-anchor">#</a> Duplicate SACK(D-SACK)</h5> <ul><li>使用SACK标识的范围，还可以知道告知发送方，有哪些数据被重复接收了</li> <li>可以让发送方知道：是发出去的包丢了，还是回来的ack包丢了</li></ul> <h3 id="超时时间的确定"><a href="#超时时间的确定" class="header-anchor">#</a> 超时时间的确定</h3> <h4 id="背景-2"><a href="#背景-2" class="header-anchor">#</a> 背景</h4> <ul><li>路由器和网络流量均会变化</li> <li>所以超时时间肯定不能设置为一个固定值</li> <li>超时长：重发慢，效率低，性能差</li> <li>超时短：并没有丢就重发，导致网络拥塞，导致更多超时和更多重发</li> <li>tcp会追踪这些变化，并相应的动态改变超时时间（RTO）</li></ul> <h4 id="如何动态改变"><a href="#如何动态改变" class="header-anchor">#</a> 如何动态改变</h4> <ul><li>每次重传的时间间隔为上次的一倍，直到最大间隔为64s，称为“指数退避”</li> <li>首次重传到最后放弃重传的时间间隔一般为9min</li> <li>依赖以往的往返时间计算（RTT）动态的计算</li></ul> <h4 id="往返时间（rtt）的计算方法"><a href="#往返时间（rtt）的计算方法" class="header-anchor">#</a> 往返时间（RTT）的计算方法</h4> <ul><li>并不是简单的ack时间和发送时间的差值。因为有重传，网络阻塞等各种变化的因素。</li> <li>而是通过采样多次数值，然后做估算</li> <li>tcp使用的方法有：
<ul><li>被平滑的RTT估计器</li> <li>被平滑的均值偏差估计器</li></ul></li></ul> <h4 id="重传时间的具体计算"><a href="#重传时间的具体计算" class="header-anchor">#</a> 重传时间的具体计算</h4> <ul><li>计算往返时间（RTT），保存测量结果</li> <li>通过测量结果维护一个被平滑的RTT估计器和被平滑的均值偏差估计器</li> <li>根据这两个估计器计算下一次重传时间</li></ul> <h3 id="超时重传引发的问题-拥塞"><a href="#超时重传引发的问题-拥塞" class="header-anchor">#</a> 超时重传引发的问题-拥塞</h3> <h4 id="为什么重传会引发拥塞"><a href="#为什么重传会引发拥塞" class="header-anchor">#</a> 为什么重传会引发拥塞</h4> <ul><li>当网络延迟突然增加时，tcp会重传数据</li> <li>但是过多的重传会导致网络负担加重，从而导致更大的延时和丢包，进入恶性循环</li> <li>也就是tcp的拥塞问题</li></ul> <h4 id="解决拥塞-拥塞控制的算法"><a href="#解决拥塞-拥塞控制的算法" class="header-anchor">#</a> 解决拥塞-拥塞控制的算法</h4> <ul><li>慢启动：降低分组进入网络的传输速率</li> <li>拥塞避免：处理丢失分组的算法</li> <li>快速重传</li> <li>快速恢复</li></ul> <h2 id="四次挥手-关闭链接"><a href="#四次挥手-关闭链接" class="header-anchor">#</a> 四次挥手-关闭链接</h2> <p>TCP 的连接的关闭需要发送四个包，因此称为<strong>四次挥手</strong>(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。</p> <ul><li><p>第一次挥手(FIN=1，seq=x)</p> <p>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p> <p>发送完毕后，客户端进入 FIN_WAIT_1 状态。</p></li> <li><p>第二次挥手(ACK=1，ACKnum=x+1)</p> <p>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</p> <p>发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。</p></li> <li><p>第三次挥手(FIN=1，seq=y)</p> <p>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。</p> <p>发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。</p></li> <li><p>第四次挥手(ACK=1，ACKnum=y+1)</p> <p>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。</p> <p>服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</p> <p>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。</p></li></ul> <p>四次挥手的示意图如下：
<img src="/blog/assets/img/tcp-connection-closed-four-way-handshake.69f6d366.png" alt="四次挥手"></p> <h3 id="为什么是四次挥手"><a href="#为什么是四次挥手" class="header-anchor">#</a> 为什么是四次挥手</h3> <ul><li>因为tcp连接是全双工的，数据在两个方向上能同时传递。</li> <li>同时tcp支持半关闭（发送一方结束发送还能接收数据的功能）。</li> <li>因此每个方向都要单独关闭，且收到关系通知需要发送确认回复。</li></ul> <h4 id="为什么要支持半关闭"><a href="#为什么要支持半关闭" class="header-anchor">#</a> 为什么要支持半关闭</h4> <ul><li>客户端需要通知服务端，它的数据已经传输完毕</li> <li>同时仍要接收来自服务端的数据</li> <li>使用半关闭的单连接效率要比使用两个tcp连接更好</li></ul> <h2 id="tcp-慢开始-14kb-规则"><a href="#tcp-慢开始-14kb-规则" class="header-anchor">#</a> TCP 慢开始 / 14kb 规则</h2> <p>第一个响应包是14kb大小。这是慢开始的一部分，慢开始是一种均衡网络连接速度的算法。慢开始逐渐增加发送数据的数量直到达到网络的最大带宽。</p> <p>在&quot;TCP slow start&quot;中，在收到初始包之后, 服务器会将下一个包的大小加倍到大约28kb。 后续的包依次是前一个包大小的二倍直到达到预定的阈值，或者遇到拥塞。</p> <p><img src="/blog/assets/img/TCP-handshake.2f5f3733.jpg" alt="TCP-handshake"></p> <p>如果您听说过初始页面加载的14Kb规则，TCP慢开始就是初始响应为14Kb的原因，也是为什么web性能优化需要将此初始14Kb响应作为优化重点的原因。TCP慢开始逐渐建立适合网络能力的传输速度，以避免拥塞。</p> <h2 id="tcp-keepalive"><a href="#tcp-keepalive" class="header-anchor">#</a> TCP KeepAlive</h2> <p>TCP 的连接，实际上是一种纯软件层面的概念，在物理层面并没有“连接”这种概念。TCP 通信双方建立交互的连接，但是并不是一直存在数据交互，有些连接会在数据交互完毕后，主动释放连接，而有些不会。在长时间无数据交互的时间段内，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些 TCP 连接并未来得及正常释放，在软件层面上，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用 TCP 的 KeepAlive 机制实现来实现。主流的操作系统基本都在内核里支持了这个特性。</p> <p>TCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。</p> <section style="border-top:2px solid #eaecef;padding-top:1rem;margin-top:2rem;"><div><span data-flag-title="Your Article Title" class="leancloud-visitors"><em class="post-meta-item-text">閲讀量： </em> <i class="leancloud-visitors-count"></i></span></div> <h3><a href="javascript:;"></a>
    評 論：
  </h3> <div id="vcomments"></div></section></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/blog/网络/请求/XMLHttpRequest/XMLHttpRequest.html" class="prev">
        XMLHttpRequest
      </a></span> <span class="next"><a href="/blog/blog/网络/安全/网络安全.html">
        网络安全
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.f0ef88ef.js" defer></script><script src="/blog/assets/js/2.8018e2e2.js" defer></script><script src="/blog/assets/js/6.595db461.js" defer></script><script src="/blog/assets/js/18.4b507252.js" defer></script>
  </body>
</html>
