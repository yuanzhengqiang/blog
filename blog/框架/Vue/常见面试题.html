<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>逆夏的博客</title>
    <meta name="generator" content="VuePress 1.5.0">
    
    <meta name="description" content="凉风把枫叶吹红，冷言让强者成熟">
    <link rel="preload" href="/blog/assets/css/0.styles.56a09861.css" as="style"><link rel="preload" href="/blog/assets/js/app.f0ef88ef.js" as="script"><link rel="preload" href="/blog/assets/js/2.8018e2e2.js" as="script"><link rel="preload" href="/blog/assets/js/35.7714042a.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.7fcf6999.js"><link rel="prefetch" href="/blog/assets/js/11.c0725cdb.js"><link rel="prefetch" href="/blog/assets/js/12.53f66bb2.js"><link rel="prefetch" href="/blog/assets/js/13.430875aa.js"><link rel="prefetch" href="/blog/assets/js/14.3dab09ed.js"><link rel="prefetch" href="/blog/assets/js/15.58f29d65.js"><link rel="prefetch" href="/blog/assets/js/16.61800840.js"><link rel="prefetch" href="/blog/assets/js/17.185af50f.js"><link rel="prefetch" href="/blog/assets/js/18.4b507252.js"><link rel="prefetch" href="/blog/assets/js/19.ec88fb23.js"><link rel="prefetch" href="/blog/assets/js/20.3a339629.js"><link rel="prefetch" href="/blog/assets/js/21.8c742bc9.js"><link rel="prefetch" href="/blog/assets/js/22.7e5987e3.js"><link rel="prefetch" href="/blog/assets/js/23.434abd07.js"><link rel="prefetch" href="/blog/assets/js/24.9dc03081.js"><link rel="prefetch" href="/blog/assets/js/25.1da05b1e.js"><link rel="prefetch" href="/blog/assets/js/26.7a4fd4c5.js"><link rel="prefetch" href="/blog/assets/js/27.7af73fd7.js"><link rel="prefetch" href="/blog/assets/js/28.a265a463.js"><link rel="prefetch" href="/blog/assets/js/29.9cc2048c.js"><link rel="prefetch" href="/blog/assets/js/3.ea5004f2.js"><link rel="prefetch" href="/blog/assets/js/30.3cc1440d.js"><link rel="prefetch" href="/blog/assets/js/31.fa029781.js"><link rel="prefetch" href="/blog/assets/js/32.c54b40e0.js"><link rel="prefetch" href="/blog/assets/js/33.9e14a36e.js"><link rel="prefetch" href="/blog/assets/js/34.0f8bd32e.js"><link rel="prefetch" href="/blog/assets/js/36.345b1d96.js"><link rel="prefetch" href="/blog/assets/js/37.958f4e57.js"><link rel="prefetch" href="/blog/assets/js/38.bb0d0bb9.js"><link rel="prefetch" href="/blog/assets/js/39.9a814394.js"><link rel="prefetch" href="/blog/assets/js/4.7e8269c2.js"><link rel="prefetch" href="/blog/assets/js/40.ddb3beb4.js"><link rel="prefetch" href="/blog/assets/js/41.f519f588.js"><link rel="prefetch" href="/blog/assets/js/42.3baa21d2.js"><link rel="prefetch" href="/blog/assets/js/43.e50fa78a.js"><link rel="prefetch" href="/blog/assets/js/44.9a2db179.js"><link rel="prefetch" href="/blog/assets/js/45.36cb132b.js"><link rel="prefetch" href="/blog/assets/js/46.33a459b0.js"><link rel="prefetch" href="/blog/assets/js/47.fdaf0f4e.js"><link rel="prefetch" href="/blog/assets/js/48.898bdb9d.js"><link rel="prefetch" href="/blog/assets/js/49.e4698de4.js"><link rel="prefetch" href="/blog/assets/js/5.ebbe82f6.js"><link rel="prefetch" href="/blog/assets/js/50.6dfaf14b.js"><link rel="prefetch" href="/blog/assets/js/51.516ec6f5.js"><link rel="prefetch" href="/blog/assets/js/52.b20e278c.js"><link rel="prefetch" href="/blog/assets/js/53.364b4c1c.js"><link rel="prefetch" href="/blog/assets/js/54.0ecbd5de.js"><link rel="prefetch" href="/blog/assets/js/6.595db461.js"><link rel="prefetch" href="/blog/assets/js/7.a8f2d87d.js"><link rel="prefetch" href="/blog/assets/js/8.b22711c9.js"><link rel="prefetch" href="/blog/assets/js/9.d3060a61.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.56a09861.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">逆夏的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/blog/引言/引言.html" class="nav-link">
  博客
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/yuanzhengqiang" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub地址
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/blog/引言/引言.html" class="nav-link">
  博客
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/yuanzhengqiang" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub地址
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>引言</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>框架</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>Vue</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/blog/框架/Vue/vue-router源码解析.html" class="sidebar-link">vue-router源码解析</a></li><li><a href="/blog/blog/框架/Vue/常见面试题.html" class="active sidebar-link">常见面试题</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>浏览器</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>缓存</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>构建</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>设计模式</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue常见面试题"><a href="#vue常见面试题" class="header-anchor">#</a> <center>vue常见面试题</center></h1> <h4 id="vue中的computed-和-watch-的区别"><a href="#vue中的computed-和-watch-的区别" class="header-anchor">#</a> vue中的computed 和 watch 的区别</h4> <ul><li>功能上：computed是计算属性，也就是依赖其它的属性计算所得出最后的值。watch是去监听一个值的变化，然后执行相对应的函数</li> <li>使用上：computed中的函数必须要用return返回；watch的回调里面会传入监听属性的新旧值，通过这两个值可以做一些特定的操作，不是必须要用return</li> <li>性能上：computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调</li> <li>场景上：computed：当一个属性受多个属性影响的时候，例子：购物车商品结算；watch：当一条数据影响多条数据的时候，例子：搜索框</li></ul> <h4 id="v-if、v-show、v-html的原理"><a href="#v-if、v-show、v-html的原理" class="header-anchor">#</a> v-if、v-show、v-html的原理</h4> <ul><li>v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染；</li> <li>v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display；</li> <li>v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值</li></ul> <h4 id="mvvm："><a href="#mvvm：" class="header-anchor">#</a> MVVM：</h4> <ul><li>M：数据模型（Model），简单的JS对象</li> <li>VM：视图模型（ViewModel），连接Model与View</li> <li>V：视图层（View），呈现给用户的DOM渲染界面</li></ul> <h4 id="virtual-dom-虚拟dom"><a href="#virtual-dom-虚拟dom" class="header-anchor">#</a> Virtual DOM(虚拟dom)</h4> <ul><li>Vue会把用户写的代码中的 标签中的代码解析成 AST 语法树，再将处理后的 AST 生成相应的 render 函数，render 函数执行后会得到与模板代码对应的虚拟 DOM，最后通过虚拟 DOM 中新旧 vnode 节点的对比和更新，渲染得到最终的真实 DOM</li> <li>用一个原生的 js 对象去描述 dom 节点的类。因为浏览器操作 dom 的成本是很高的，所以利用 vnode 生成虚拟 dom 比创建一个真实 dom 的代价要小很多。</li> <li>虚拟 DOM 不会立马进行排版与重绘操作，频繁修改时虚拟DOM会合并修改，然后一次性比较并修改真实 DOM 中需要改的部分，只渲染局部，减少过多 DOM 节点排版与重绘的损耗</li></ul> <h4 id="diff算法"><a href="#diff算法" class="header-anchor">#</a> Diff算法</h4> <ul><li>每次修改数据之后，生成一个新的虚拟dom，和旧的虚拟dom比较的算法</li> <li>Diff算法比较的时候，只会在同层级进行，不会跨层级比较</li> <li>Diff 算法是逐层进行比对，只有同层级的节点进行比对，因此时间的复杂度只有 O(n)</li> <li>Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。</li> <li>Vue3在创建VNode时就确定其类型，以及在mount/patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。该算法中还运用了动态规划的思想求解最长递归子序列。</li></ul> <h4 id="vue响应式原理"><a href="#vue响应式原理" class="header-anchor">#</a> Vue响应式原理</h4> <ul><li>通过Object.defineProperty()来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发相应的监听回调</li> <li>提供三个模块
<ul><li>Observer：能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者.</li> <li>Compile：对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。</li> <li>Watcher：链接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应的回调函数，从而更新试图。</li></ul></li> <li>3.0使用Proxy和Object.defineProperty对比
<ul><li>Object.defineProperty只能劫持对象已存在的属性，我们需要对每个对象的每个属性进行遍历，无法监控到数组下标的变化，无法响应新增属性</li> <li>Proxy是对对象的监听而非属性，并返回一个新对象，能够相应数组变化，新增属性，但是ie11以下不兼容</li> <li>Proxy只需要代理一次，对象内的值发生了改变就会被感知到，不再需要像以前为对象的每个值进行数据劫持，对象的新增，数组的下标设置0清空等情况都可以被感知到</li> <li>Object.defineProperty解决对象新增的方法是提供 $set 方法，对于数组的感知通过重写了数组的push，shift等方法</li></ul></li></ul> <h4 id="vue的组件通信"><a href="#vue的组件通信" class="header-anchor">#</a> Vue的组件通信</h4> <ul><li>props 和 $emit</li> <li>$children 和 $parent</li> <li>EventBus</li> <li>ref</li> <li>Provide 和 Inject</li> <li>vuex</li></ul> <h4 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h4> <ul><li>beforeCreate：实例初始化之后，this指向创建实例，不能访问到data、computed、watch、method上订单方法和数据</li> <li>created：实例创建完成，可访问data、computed、watch、method上的方法和数据，未挂载到DOM，不能访问到$el属性，$ref属性内容为空数组</li> <li>beforeMount：在挂载开始之前被调用，beforeMount之前，会找到对应的template，并编译成render函数</li> <li>mounted：实例挂载到DOM上，此时可以通过DOMAPi获取到DOM节点，$ref属性可以访问</li> <li>beforeUpdate：响应式数据更新时调用，发生在虚拟DOM打补丁之前</li> <li>updated：虚拟DOM重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作</li> <li>activated：keep-alive开启时调用</li> <li>deactivated：keep-alive关闭时调用</li> <li>beforeDestroy：实例销毁之前调用。实例仍然完全可用，this仍能获取到实例</li> <li>destroyed：实例销毁后调用，调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁</li></ul> <h4 id="vue组件中data必须是一个函数"><a href="#vue组件中data必须是一个函数" class="header-anchor">#</a> Vue组件中data必须是一个函数</h4> <ul><li>当一个组件被定义，data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。</li></ul> <h4 id="vue-runtime-js-vue-js"><a href="#vue-runtime-js-vue-js" class="header-anchor">#</a> vue.runtime.js/vue.js</h4> <ul><li>vue.js同时包含编译器和运行时的版本。</li> <li>runtime是运行时版本，只包含用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。</li> <li>编译器就是用来将模板字符串<code>&lt;template&gt;&lt;/template&gt;</code>编译成为渲染函数</li></ul> <h4 id="nexttick："><a href="#nexttick：" class="header-anchor">#</a> $nextTick：</h4> <ul><li>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</li> <li>Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。</li> <li>Vue在2.4版本、2.5版本和2.6版本中对于nextTick进行反复变动，原因是浏览器对于微任务的不兼容性影响、微任务和宏任务各自优缺点的权衡</li> <li>降级选择使用 Promise -&gt; MutationObserver -&gt; setImmediate -&gt; setTimeout 方法</li></ul> <h4 id="vue-js-整个实现原理"><a href="#vue-js-整个实现原理" class="header-anchor">#</a> Vue.js 整个实现原理</h4> <ul><li>new Vue()之后，在init过程会初始化生命周期，事件中心，渲染、执行beforeCreate、初始化data、props、computed、watcher、执行created，然后调用$mount方法对Vue实例进行挂载</li> <li>挂载的核心过程包括模板编译、渲染以及更新三个过程</li> <li>如果是template则先将template编译为render function，否则直接调用$mount的mountComponent方法，先执行beforeMount，然后实例化一个渲染Watcher，在它的回调函数中调用updateComponent方法</li> <li>然后调用render方法将render function渲染成虚拟Dom</li> <li>接着调用update方法，update方法又会调用pacth方法把虚拟 DOM 转换成真正的 DOM 节点，在pacth转换时如果没有旧的虚拟DOM，则直接生成真实DOM，如果有则需要经过Diff算法比较新旧虚拟DOM，然后修改真实DOM</li></ul> <h4 id="computed和watch的区别"><a href="#computed和watch的区别" class="header-anchor">#</a> computed和watch的区别</h4> <ul><li>computed：计算属性，根据依赖的值返回一个值，有缓存机制，除非依赖的响应式属性变化才会重新计算，不能接受参数，可以依赖其他computed，甚至是其他组件的data，不能与data中的属性重复</li> <li>watch：一个对象，键是需要观察的值，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。可接受两个参数（当前值和旧值），监听数据改变时会触发回调，监听的属性必须是存在的，允许异步，不返回值</li></ul> <h4 id="模版编译原理"><a href="#模版编译原理" class="header-anchor">#</a> 模版编译原理</h4> <ul><li>首先解析模版，生成AST语法树(一种用JavaScript对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。</li> <li>Vue的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。</li> <li>最后将优化后的AST树转换为可执行的代码。</li></ul> <h4 id="keep-alive"><a href="#keep-alive" class="header-anchor">#</a> keep-alive</h4> <ul><li>实现组件缓存，当组件切换时不会对当前组件进行卸载</li> <li>添加了两个生命周期activated/deactivated，用来得知当前组件是否处于活跃状态</li> <li>初次加载时会经过beforeCreate，created，beforeMount，mounted，在再次加载时不会触发这些生命周期，因为不会被卸载，所以也不会触发beforeDestroy和destroyed</li></ul> <h4 id="当vue的列表没有设置key和不设置key"><a href="#当vue的列表没有设置key和不设置key" class="header-anchor">#</a> 当vue的列表没有设置key和不设置key</h4> <ul><li>不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法</li> <li>而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</li> <li>当 key 未绑定时，主要通过元素的标签等进行判断是否为同一节点</li> <li>如果 VNode 中只包含了文本节点，在 patchVnode 中可以直接替换文本节点，而不需要移动节点的位置，确实在不绑定 key 的情况下效率要高一丢丢。</li> <li>在实际项目中，大多数情况下 v-for 的节点内并不只有文本节点，那么 VNode 的字节点就要进行销毁和创建的操作。</li></ul> <h4 id="为什么说vue-的响应式更新比-react快"><a href="#为什么说vue-的响应式更新比-react快" class="header-anchor">#</a> 为什么说Vue 的响应式更新比 React快</h4> <ul><li>Vue
<ul><li>Vue 对于响应式属性的更新，只会精确更新依赖收集的当前组件，而不会递归的去更新子组件</li> <li>每个组件都有自己的渲染 watcher，它掌管了当前组件的视图更新，但是并不会掌管 ChildComponent 的更新。</li> <li>响应式元素在传给子组件的时候，会被保存在子组件实例的 _props 上，并且被定义成了响应式属性，而子组件的模板中对于 props.msg 的访问其实是被代理到 _props.msg 上去的，所以自然也能精确的收集到依赖，父组件发生重渲染的时候，是会重新计算子组件的 props 的</li> <li>使用slot时，收集到的是父组件的渲染watcher，当遇到slot是会直接调用slot组件vm实例上的 $forceUpdate，所触发的渲染watcher就是属于slot的渲染watcher，触发了两层渲染，父组件和slot的</li></ul></li> <li>React
<ul><li>React 是自顶向下的进行递归更新的，也就是说，React 中假如 ChildComponent 里还有十层嵌套子元素，那么所有层次都会递归的重新render（在不进行手动优化的情况下），这是性能上的灾难。（因此，React 创造了Fiber，创造了异步渲染）。</li> <li>遵从Immutable的设计思想，永远不在原对象上修改属性，永远返回一个新的对象，无法知道修改了旧对象的哪部分</li></ul></li></ul> <h4 id="vue-router"><a href="#vue-router" class="header-anchor">#</a> Vue-Router</h4> <h5 id="模式和原理："><a href="#模式和原理：" class="header-anchor">#</a> 模式和原理：</h5> <ul><li>hash路由，使用 URL 的 hash 来模拟一个完整的 URL，无需后端路由映射，使用window.onhashchange监听url变化</li> <li>history路由，基于history模式，需要后端路由映射，否则在内页刷新页面会404，使用Html5中新增的window.addEventListener(&quot;popstate&quot;,function(){})监听url变化，使用pushState/replaceState来改变url</li></ul> <h5 id="路由钩子：用来做鉴权路由拦截"><a href="#路由钩子：用来做鉴权路由拦截" class="header-anchor">#</a> 路由钩子：用来做鉴权路由拦截</h5> <ul><li>全局：beforeEach，beforeResolve，afterEach</li> <li>独享：单个路由的beforeEnter，beforeLeave</li> <li>路由组件：beforeRouteEnter，beforeRouteUpdate，beforeRouteLeave</li></ul> <h5 id="路由懒加载"><a href="#路由懒加载" class="header-anchor">#</a> 路由懒加载</h5> <ul><li>路由定义处引入的组建使用Dynamic imports：<code>()=&gt;import('comp')</code></li></ul> <h4 id="vuex"><a href="#vuex" class="header-anchor">#</a> Vuex</h4> <h5 id="配置项"><a href="#配置项" class="header-anchor">#</a> 配置项</h5> <ul><li>Strict: 严格模式，所有的state修改都要通过Mutation</li> <li>State：应用的状态数据</li> <li>Getter：类似计算属性</li> <li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数</li> <li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作</li> <li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中
<ul><li>默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的</li> <li>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名</li></ul></li> <li>Plugins：插件</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/blog/框架/Vue/vue-router源码解析.html" class="prev">
        vue-router源码解析
      </a></span> <span class="next"><a href="/blog/blog/框架/React/常见面试题.html">
        常见面试题
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.f0ef88ef.js" defer></script><script src="/blog/assets/js/2.8018e2e2.js" defer></script><script src="/blog/assets/js/35.7714042a.js" defer></script>
  </body>
</html>
